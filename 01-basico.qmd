---
engine: julia
lang: es-MX

---

## El lenguaje de programaci√≥n Julia {#sec-julia}
El c√≥digo se organiza en scripts, m√≥dulos y paquetes. Cada uno de estos define tipos y funciones que interactuan para componer las soluciones deseadas.

El resto de esta unidad esta dedicada a precisar la sintaxis del lenguaje y anotaciones de importancia sobre su funcionamiento.

## Instalaci√≥n

El sitio oficial recomienda el uso de `juliaup`, una herramienta que permite manejar diferentes versiones de Julia y mantenerlas actualizarlas.

[https://julialang.org/install/](https://julialang.org/install/)

Las versiones de Julia siguen el paradigma de _semantic versioning_ (semver), por lo que `juliaup` permite gestionarlas de manera simple y efectiva. La versi√≥n estable es la 1.10 y las m√°s nuevas son la 1.11 y la 1.12.

Tambi√©n es posible usar Colab de Google con el kernel para `Julia`; este usar julia 1.11 y hasta el momento, es el √∫nico disponible.

## Manos a la obra
Una vez instalado, se puede ejecutar un REPL de Julia en la terminal ejecutando

```{{bash}}
$ julia
```

dado que instalamos con `juliaup` podemos mantener diferentes versiones, e.g., 

```{{bash}}
$ juliaup list
```

que nos mostrar√° una larga lista de posibles _channels_ o versiones de instalaci√≥n

```{{bash}}

$ juliaup add 1.10
$ juliaup default 1.10
``` 

estas instrucciones a√±adir√°n la versi√≥n 1.10 y la establecer√° como versi√≥n o canal por omisi√≥n. Puedes llamar diferentes versiones ejecutando `julia +channel` como sigue:

```{{bash}}
$ julia +1.12

               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.12.1 (2025-10-17)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org release
|__/                   |

julia>

``` 

### Creando un "Hola mundo"
Uno de los programas m√°s comunes es el siguiente
```{julia}
println("¬°Hola üåé!")
```

### Usando Colab
Es posible usar Colab para reducir la complejidad de la instalaci√≥n, ya que cuenta con un kernel de Julia. Como se mencionaba anteriormente, solo se soporta la versi√≥n `1.11` que es suboptima con las versiones de paquetes que usaremos m√°s adelante. Adicionalmente, se tiene limitante de los recursos limitados que se nos proporcionen, en particular al momento de escribir estas notas, aunque los recursos que se otorgan suelen ser suficientes para pruebas, no lo son en otros √°mbitos: solo se tienen 2 vcpus y tiempos de ejecuci√≥n limitados.

### Usando Jupyter
Una vez instalado julia; debemos instalar el paquete `IJulia` que instalar√° todo lo necesario para correr Jupyter (ver la secci√≥n de `Pkg` al final de esta unidad para m√°s informaci√≥n sobre paquetes). Una vez corriendo, se debe seleccionar crear un notebook espec√≠ficando el kernel de Julia para utilizarlo.

## Sintaxis y estructuras
### Funciones
Las funciones son centrales en Julia. Por ahora veremos la estructura y m√°s adelante, definiremos algunas.

Para ejecutar una funci√≥n se utiliza la sintaxis `fun(arg)`, esta regresar√° un valor, que depende de la funci√≥n misma y muchas veces del tipo que tenga `arg`. Si fueran dos argumentos `fun(arg1, arg2)`, etc. Tambi√©n se soportan argumentos con nombre `fun(arg1, arg2, ...; kwarg=val)` (_kwargs_ para nombrarlos de manera sint√©tica). En este caso, los _kwargs_ no influyen en los tipos de salida. Esto puede parecer extra√±o pero es debido a las decisiones de implementaci√≥n relacionadas con el desempe√±o. 

Las funciones se definen como sigue:
```julia
function fun(arg1, arg2...) # <1>
    # ... expresiones ...
end

function fun(arg1, arg2...; kwarg1=valor1, kwargs2...) # <2>
    # ... expresiones ...
end

fun(arg1, arg2...; kwarg1=valor1, kwargs2...) = expresion  # <3>

(arg1, arg2...; kwarg1=valor1, kwargs2...) -> expresion       # <4>

fun() do x # <5>
    x^2 # ... expresiones ...
end
```
1. Definici√≥n de una funci√≥n simple, los tipos de los argumentos se utilizan para generar m√∫ltiples versiones de una funci√≥n.
2. Tambi√©n se soportan argumentos nombrados, los cuales van despu√©s de `;`, se debe tener en cuenta que los tipos de los argumentos nombrados no son utilizados para determinar si una funci√≥n debe compilarse. Los argumentos nombrados pueden o no tener valores por omisi√≥n.
3. Si la funci√≥n tiene una estructura simple, de una expresi√≥n, es posible ignorar `function` y `end`, usando '=' para definirla.
4. Muchas veces es √∫til definir funciones an√≥nimas, que suelen pasarse a otras funciones de orden superior.
5. Un embellecedor √∫til para generar una funci√≥n an√≥nima (definida entre `do...end`) que se pasa como primer argumento a `fun`, e.g., es equivalente a `fun(x->x^2).`

El _√°mbito_ o _scope_ de las variables en Julia es sint√°ctico, que significa que se hereda del c√≥digo donde las funciones fueron definidas, y no din√°mico (que se hereda desde d√≥nde se ejecuta la funci√≥n). Aunque es el comportamiento de la mayor√≠a de los lenguajes modernos, es importante conocerlo sobre todo para la creaci√≥n de _cerraduras sint√°cticas_ en funciones.


### Expresiones y operadores
Las _expresiones_ son la forma m√°s gen√©rica de expresar el c√≥digo en Julia, comprenden operaciones aritm√©ticas, asignaci√≥n y declaraci√≥n de variables, definiciones de bloques de c√≥digo, llamadas de funciones, entre otras.

Cada linea suele ser una expresi√≥n, a menos que se extienda por m√∫ltiples lineas por medio de un agrupador de c√≥digo o datos, estos pueden ser 

::: {.columns}

::: {.column width="33%"}
```julia
begin
    ...
end

let
    ...
end

(...)

[...]

[...]
```
:::

::: {.column width="33%"}
```julia
for el in col
    ...
end

while cond
    ...
end

if cond
    ...
elseif cond
    ...
else
    ...
end

```
:::

::: {.column width="33%"}
```julia
function fun(...)
    ...
end

try
    ...
catch
    ...
finally
    ...
end

```
:::

:::


entre las m√°s utilizadas; claramentre hay infinidad de formas de componerlas para formar los algoritmos que se esten escribiendo.

### Comentarios
Los comentarios en Julia se hacen por linea o por bloque.

Para comentar una linea se usa el car√°cter hash `#` y define una linea comentada desde ese punto  hasta el salto de linea

```{julia}
# los siguientes son comentarios de linea completos, por lo que no se imprimir√°n
#println(:hola === :hola)
#println(typeof(:hola)) 
println(Symbol("hola mundo"))  # este s√≠ se imprimir√°, pero este comentario no
```

Para comentar por bloque, dicho bloque se encierra entre `#= ... =#`

```{julia}
println("hola mundo!" #=Symbol("hola mundo")=#)
```

### Documentaci√≥n 
La documentaci√≥n oficial se encuentra en <https://docs.julialang.org>; la cu√°l cubre el lenguaje y las bibliotecas estandar. Fuera de eso, habr√° que ver los sitios y documentaciones de cada paquete, que casi siempre estan en _github_.

Actualmente los chatbots como ChatGPT y Gemini tambi√©n pueden ser una buena fuente de informaci√≥n sobre el API y las formas de trabajo. Nota: siempre se debe corroborar la informaci√≥n, ya que suelen alucinar.

La manera _empotrada_ de consultar la documentaci√≥n sobre una funci√≥n es con el prefijo `?` en el REPL.

::: {style="margin-left: 2cm; background-color: lightgray;"}
#### Ejemplo
Nota: Las ligas que salen estan rotas ya que no se adjunta la documentaci√≥n en este manuscrito.

```{julia}
?println("holi")
```

:::



Esto tambi√©n indica que debemos documentar nuestro c√≥digo, en particular se hace de la siguiente forma

```{{julia}}

"""
    fun(...)

Esta funci√≥n es un ejemplo de documentaci√≥n
"""
function fun(...)
    ...
end
```


#### Definici√≥n de variables
Las definiciones de variables tienen la sintaxis `variable = valor`; las variables comunmente comienzan con una letra o `_`, las letras pueden ser caracteres _unicode_, no deben contener espacios ni puntuaciones como parte del nombre; `valor` es el resultado de evaluar o ejecutar una expresi√≥n.

Los operadores m√°s comunes son los aritm√©ticos `+`, `-`, `*`, `/`, `√∑`, `%`, `\`, `^`,  con precedencia y significado t√≠pico. Existen maneras compuestas de modificar una variable anteponiendo el operador aritm√©tico al simbolo de asignaci√≥n, e.g., `variable += valor`, que se expande a `variable = variable + valor`. Esto implica que `variable` debe estar previamente definida previo a la ejecuci√≥n.


Los operadores l√≥gicos tambi√©n tienen el significado esperado.

|operaci√≥n  |descripci√≥n|
|---        |---- |
| `a && b`  | AND l√≥gico                       |
| `a || b`  | OR l√≥gico                        |
| `a ‚äª b`   | XOR l√≥gico                       |
| `!a`      | negaci√≥n l√≥gica                  |
| `a < b`   | comparaci√≥n `a` es menor que `b` |
| `a > b`   | comparaci√≥n `a` es mayor que `b` |
| `a <= b`  | comparaci√≥n `a` es menor o igual que `b`     |
| `a >= b`  | comparaci√≥n `a` es mayor o igual que `b`     |
| `a == b`  | comparaci√≥n de igualdad                      |
| `a === b` | comparaci√≥n de igualdad (a nivel de tipo)    |
| `a != b`  | comparaci√≥n de desigualdad                   |
| `a !== b` | comparaci√≥n de desigualdad (a nivel de tipo) |

En particular `&&` y `||` implementan _corto circuito de c√≥digo_, por lo que pueden usarse para el control de que operaciones se ejecutan. Cuando se compara a nivel de tipo 0 (entero) ser√° diferente de 0.0 (real).

Tambi√©n hay operadores l√≥gicos a nivel de bit, los argumentos son enteros.

|operaci√≥n |descripci√≥n|
|---  |--- |
| `a & b`  | AND a nivel de bits              |
| `a | b`  | OR a nivel de bits               |
| `a ‚äª b`  | XOR a nivel del bits             |
| `~a`     | negaci√≥n l√≥gica a nivel de bits  |

#### Literales
Los valores literales son valores explicitos que Julia permite para algunos tipos de datos, y que permiten definirlos de manera simple; permitiendonos escribir datos directamente en el c√≥digo.

Los n√∫meros enteros se definen sin punto decimal, es posible usar `_` como separador y dar m√°s claridad al c√≥digo. Los enteros pueden tener 8, 16, 32, o 64 bits; por omisi√≥n, se empaquetan en variables del tipo `Int` (`Int64`). Los valores hexadecimales se interpretan como enteros sin signo, y adem√°s se empaquetan al n√∫mero de bits necesario minimo para contener. El comportamiento para valores en base 10 es el de hexadecimal es congruente con un lenguaje para programaci√≥n de sistemas.

```{julia}
a = 100
println((a, sizeof(a)))
b = Int8(100)
println((b, sizeof(b)))
c = 30_000_000
println((c, sizeof(c)))
d = 0xffff
println((d, sizeof(d)))
```

::: {.column-margin}
Existen n√∫meros enteros de precisi√≥n 128 pero las operaciones al d√≠a de hoy no son implementadas de manera nativa por los procesadores; as√≠ mismo se reconocen n√∫meros de punto flotante de precisi√≥n media `Float16` pero la mayor√≠a de los procesadores no tienen soporte nativo para realizar operaciones con ellos, aunque los procesadores de √∫ltima generaci√≥n si lo tienen.
:::

Si la precisi√≥n esta en duda o el contexto lo am√©rita, deber√° especificarlo usando el constructor del tipo e.g., `Int8(100)`, `UInt8(100)`, `Int16(100)`, `UInt16(100)`, `Int32(100)`, `UInt32(100)`, `Int64(100)`, `UInt64(100)`.

Los n√∫meros de punto flotante tienen diferentes formas de definirse, teniendo diferentes efectos.
Para n√∫meros de precision simple, 32 bits, se definen con el sufijo `f0` como `3f0`. El sufijo `e0` tambi√©n se puede usar para definir precisi√≥n doble (64 bit). El cero del sufijo en realidad tiene el objetivo de colocar el punto decimal, en notaci√≥n de ingenier√≠a, e.g., $0.003$ se define como $3f-3$ o $3e-3$, dependiendo del tipo de dato que se necesite. 
Si se omite sufijo y se pone solo punto decimal entonces se interpretar√° como precision doble. Los tipos son `Float32` y `Float64`.

Los datos booleanos se indican mediante `true` y `false` para verdadero y falso, respectivamente.

Los caracteres son s√≠mbolos para √≠ndicar cadenas, se suelen representar como enteros peque√±os en memoria. Se especifican con comillas simples `'a'`, `'z'`, `'!'` y soporta simbolos _unicode_ `'ü§†'`.

Las cadenas de caracteres son la manera de representar textos como datos, se guardan en zonas contiguas de memoria. Se especifican con comillas dobles y tambi√©n soportan s√≠mbolos unicode, e.g., `"hola mundo"`, `"pato es un üê∑"`.

::: {.column-margin}
Julia guarda los s√≠mbolos de manera especial y pueden ser utilizados para realizar identificaci√≥n de datos eficiente, sin embargo, no es buena idea saturar el sistema de manejo de s√≠mbolos por ejemplo para crear un vocabulario ya que no liberar√° la memoria despu√©s de definirlos ya que es un mec√°nismo dise√±ado para la representaci√≥n de los programas, pero lo suficientemente robusto y bien definido para usarse en el dise√±o e implementaci√≥n de programas de los usuarios.
:::

En Julia existe la noci√≥n de s√≠mbolo, que es una cadena que adem√°s solo existe en una posici√≥n en memoria se usa el prefijo `:` para denotarlos. 

```{julia}
println(:hola === :hola)
println(typeof(:hola))
println(Symbol("hola mundo"))
```

### Control de flujo
El control de flujo nos permite escoger que partes del c√≥digo se ejecutaran como consecuencia de la evaluaci√≥n de una expresi√≥n, esto incluye repeticiones.

Las condicionales son el control de flujo m√°s simple.
```{julia}
a = 10
if a % 2 == 0 # <1>
    "par" # <2>
else
    "impar" # <3>
end
```
1. Expresi√≥n condicional.
2. Expresi√≥n a ejecutarse si (1) es verdadero.
3. Expresi√≥n a evaluarse si (1) es falso.

Se puede ignorar la clausula `else` dando solo la opci√≥n de evaluar (2) si (1) es verdadero. Finalmente, note que la condicional es una expresi√≥n y devuelve un valor.
```{julia}
a = 10
if log10(a) == 1 # <1>
    "es 10" # <2>
end
```

Tambi√©n pueden concatenarse m√∫ltiples expresiones condicionales con `elseif` como se muestra a continuaci√≥n.
```{julia}
a = 9
if a % 2 == 0
    println("divisible entre 2")
elseif a % 3 == 0
    println("divisible entre 3")
else
    println("no divisible entre 2 y 3")
end
```

Es com√∫n utilizar la sintaxis en Julia (short circuit) para control de flujo:
```{julia}
a = 9

println(a % 2 == 0 && "es divisible entre dos")  # <1>
println(a % 3 == 0 && "es divisible entre tres") # <2>
```
1. El resultado de la condici√≥n es falso, por lo que no se ejecutar√° la siguiente expresi√≥n.
2. El resultado es verdadero, por lo que se ejecutar√° la segunda expresi√≥n.

Fnalmente, existe una condicional de tres vias `expresion ? expr-verdadero : expr-falso`

```{julia}
a = 9

println(a % 2 == 0 ? "es divisible entre dos" : "no es divisible entre dos")
println(a % 3 == 0 ? "es divisible entre tres" : "no es divisible entre tres")
```

#### Ciclos

Los ciclos son expresiones de control de flujo que nos permiten iterar sobre una colecci√≥n o repetir un c√≥digo hasta que se cumpla alguna condici√≥n. En Julia existen dos expresiones de ciclos: 

- `for x in colecci√≥n ...expresiones... end` y
- `while condici√≥n ...expresioens... end`

En el caso de `for`, la idea es iterar sobre una colecci√≥n, esta colecci√≥n puede ser un rango, i.e., `inicio:fin`, `inicio:paso:fin`, o una colecci√≥n como las tuplas, los arreglos, o cualquiera que cumpla con la interfaz de colecci√≥n iterable del lenguaje. 

```{julia}
for i in 1:5
    println("1er ciclo: ", i => i^2)
end

for i in [10, 20, 30, 40, 50]
    println("2do ciclo: ", i => i/10)
end
```

Al igual que en otros lenguajes modernos, se define la variante completa o _comprehensive for_ que se utiliza para transformar la colecci√≥n de entrada en otra colecci√≥n cuya sintaxis se ejemplifica a continuaci√≥n:

```{julia}
a = [i => i^2 for i in 1:5]
println(a)
```

Tambi√©n es posible definir un generador, esto es, un c√≥digo que puede generar los datos, pero que no los generar√° hasta que se les solicite.
```{julia}
a = (i => i^2 for i in 1:5)
println(a)
println(collect(a)) 
```

Otra forma de hacer ciclos de intrucciones es repetir mientras se cumpla una condici√≥n:
```{julia}
i = 0
while i < 5
    i += 1
    println(i)
end

i
```

### Tuplas y arreglos en Julia
Una tupla es un conjunto ordenado de datos que no se puede modificar y que se desea esten contiguos en memoria, la sintaxis en memoria es como sigue:
```{julia}
a = (2, 3, 5, 7)    # <1>
b = (10, 20.0, 30f0)   # <1>
c = 100 => 200 # <1>
println(typeof(a))  # <2>
println(typeof(b))  # <2>
println(typeof(c))  # <2>
a[1], a[end], b[3], c.first, c.second  # <3>
```
1. Define las tuplas.
2. Imprime los tipos de las tuplas.
3. Muestra como se accede a los elementos de las tuplas. Julia indexa comenzando desde 1, y el t√©rmino `end` tambi√©n se utiliza para indicar el √∫ltimo elemento en una colecci√≥n ordenada.

La misma sintaxis puede generar diferentes tipos de tuplas. En el caso `NTuple{4, Int4}` nos indica que el tipo maneja cuatro elementos de enteros de 64 bits, los argumentos entre `{}` son parametros que especifican los tipos en cuesti√≥n.  En el caso de `Tuple` se pueden tener diferentes tipos de elementos. La tupla `Pair` es especial ya que solo puede contener dos elementos y es b√°sicamente para _embellecer_ o _simplificar_ las expresiones; incluso se crea con la sintaxis `key => value` y sus elementos pueden accederse mediante dos campos nombrados.

Los _arreglos_ son datos del mismo tipo contiguos en memoria, a diferencia de las tuplas, los elementos se pueden modificar, incluso pueden crecer o reducirse. Esto puede implicar que se alojan en zonas de memoria diferente (las tuplas se colocan en el _stack_ y los arreglos en el _heap_, ver la siguiente unidad para m√°s informaci√≥n). Desde un alto nivel, los arreglos en Julia suelen estar asociados con vectores, matrices y tensores, y un arsenal de funciones relacionadas se encuentran definidas en el paquete `LinearAlgebra`, lo cual esta m√°s all√° del alcance de este curso. 

```{julia}
a = [2, 3, 5, 7]   # <1>
b = [10, 20.0, 30f0]   # <1>
println(typeof(a))  # <2>
println(typeof(b))  # <2>
a[1], a[end], b[3], b[2:3]  # <3>
```
1. Define los arreglos `a` y `b`.
2. Muestra los tipos de los arreglos, note como los tipos se promueven al tipo m√°s g√©nerico que contiene la definici√≥n de los datos.
3. El acceso es muy similar a las tuplas para arreglos unidimensionales, note que es posible acceder rangos de elementos con la sintaxis `ini:fin`.

```{julia}
a = [2 3;
     5 7]    # <1>
display(a)  # <2>
display(a[:, 1]) # <3>
display(a[1, :]) # <4>
```
1. Definici√≥n de un arreglo bidimensional, note como se ignora la coma `,` en favor de la escritura por filas separadas por `;`.
2. La variable `a` es una matriz de 2x2.
3. Es posible acceder una columna completa usando el s√≠mbolo `:` para indicar todos los elementos.
4. De igual forma, es posible acceder una fila completa.

### Diccionarios y conjuntos en Julia
Un diccionario es un arreglo asociativo, i.e., guarda pares llave-valor. Permite acceder de manera eficiciente al valor por medio de la llave, as√≠ como tambi√©n verificar si hay una entrada dentro del diccionario con una llave dada. La sintaxis es como sigue:

```{julia}
a = Dict(:a => 1, :b => 2, :c => 3) # <1>
a[:b] = 20 # <2>
println(a)
a[:d] = 4  # <3>
println(a)
delete!(a, :a) # <4>
a
```
1. Definici√≥n del diccionario `a` que mapea simbolos a enteros.
2. Cambia el valor de `:b` por 20.
3. A√±ade `:d => 4` al diccionario `a`.
4. Borra el par con llave `:a`.

Es posible utilizar diferentes tipos siempre y cuando el tipo en cuesti√≥n defina de manera correcta la funci√≥n `hash` sobre la llave y la verificaci√≥n de igualdad `==`.

Un conjunto se representa con el tipo `Set`, se implementa de manera muy similar al diccionario pero solo necesita el elemento (e.g., la llave). Como conjunto implementa las operaciones clasificaci√≥n de operaciones de conjuntos
```{julia}
a = Set([10, 20, 30, 40]) # <1>
println(20 in a)          # <2>
push!(a, 50)              # <3>
println(a)
delete!(a, 10)            # <4>
println(a)
println(intersect(a, [20, 35])) # <5>
union!(a, [100, 200]) # <6>
println(a)
```
1. Definici√≥n del conjunto de n√∫meros enteros.
2. Verificaci√≥n de membresia al conjunto `a`.
3. A√±ade 50 al conjunto.
4. Se borra el elemento 10 del conjunto.
5. Intersecci√≥n de `a` con una colecci√≥n, no se modifica el conjunto `a`.
6. Uni√≥n con otra colecci√≥n, se modifica `a`.

## El flujo de compilaci√≥n de Julia

Basta con escribir una linea de c√≥digo en el REPL de Julia y esta se compilar√° y ejecutar√° en el contexto actual, usando el √°mbito de variables. Esto es conveniente para comenzar a trabajar, sin embargo, es importante conocer el flujo de compilaci√≥n para tenerlo en cuenta mientras se c√≥difica, y as√≠ generar c√≥digo eficiente. En particular, la creaci√≥n de funciones y evitar la _inestabilidad_  de los tipos de las variables es un paso hacia la generaci√≥n de c√≥digo eficiente. Tambi√©n es importante evitar el alojamiento de memoria din√°mica siempre que sea posible. A continuaci√≥n se mostrar√° el an√°lisis de un c√≥digo simple a diferentes niveles, mostrando que el lenguaje nos permite observar la generaci√≥n de c√≥digo, que √∫ltimadamente nos da cierto control y nos permite verificar que lo que se esta implementando es lo que se espec√≠fica en el c√≥digo. Esto no es posible en lenguajes como Python.


```{julia}
#| code-line-numbers: true
let
    e = 1.1
    println(e*e)
    @code_typed e*e
end
```

En este c√≥digo, se utiliza la estructa de agrupaci√≥n de expresiones `let...end`. Cada expresi√≥n puede estar compuesta de otras expresiones, y casi todo es una expresi√≥n en Julia. La mayoria de las expresiones ser√°n finalizadas por un salto de linea, pero las compuestas como `let`, `begin`, `function`, `if`, `while`, `for`, `do`, `module` estar√°n finalizadas con `end`. La indentaci√≥n no importa la indentaci√≥n como en Python, pero es aconsejable para mantener la legibilidad del c√≥digo. La linea 2 define e inicializa la variable `e`; la linea 3 llama a la funci√≥n `println`, que imprimir√° el resultado de `e*e` en la consola. La funci√≥n `println` esta dentro de la biblioteca est√°ndar de Julia y siempre esta _visible_. La linea 4 es un tanto diferente, es una macro que toma la expresi√≥n `e*e` y realiza algo sobre la expresi√≥n misma, en particular `@code_type` muestra como se reescribe la expresi√≥n para ser ejecutada. Note como se har√° una llamada a la funci√≥n `Base.mul_float` que recibe dos argumentos y que regresar√° un valor `Float64`. Esta informaci√≥n es necesaria para que Julia pueda generar un c√≥digo veloz, el flujo de compilaci√≥n llevar√≠a esta informaci√≥n a generar un c√≥digo intermedio de _Low Level Virtual Machine_ (LLVM), que es el compilador empotrado en Julia, el cual estar√≠a generando el siguiente c√≥digo LLVM (usando la macro `@code_llvm`):

```{julia}
#| echo: false
let
    e = 1.1
    @code_llvm e*e
end
```

Este c√≥digo ya no es espec√≠fico para Julia, sino para la maquinar√≠a LLVM. Observe la especificidad de los tipos y lo corto del c√≥digo. El flujo de compilaci√≥n requerir√≠a generar el c√≥digo nativo, que puede ser observado a continuaci√≥n mediante la macro `@code_native`:

```{julia}
#| echo: false
let
    e = 1.1
    @code_native e*e
end
```

En este caso podemos observar c√≥digo espec√≠fico para la computadora que esta generando este documento, es posible ver el manejo de registros y el uso de instrucciones del CPU en cuesti√≥n.

Este c√≥digo puede ser eficiente dado que los tipos y las operaciones son conocidos, en el caso que esto no puede ser, la eficiencia esta perdida. Datos no nativos o la imposibilidad de determinar un tipo causar√≠an que se generar√° m√°s c√≥digo nativo que terminar√≠a necesitanto m√°s recursos del procesador. Una situaci√≥n similar ocurre cuando se aloja memoria de manera din√°mica. Siempre estaremos buscando que nuestro c√≥digo pueda determinar el tipo de datos para que el c√≥digo generado sea simple, si es posible usar datos nativos, adem√°s de no manejar o reducir el uso de memor√≠a din√°mica.

## Ejemplos de funciones
Las funciones ser√°n una parte central de nuestros ejemplos, por lo que vale la pena retomarlas y dar ejemplos.

```{julia}
function f(x)
    x^2
end
```

Siempre regresan el valor de la √∫ltima expresi√≥n; note como el tipo (y no solo el valor) de retorno depende del tipo de la entrada, e.g., si `x` es un entero entonces `x^2` ser√° un entero, pero si `x` es una matriz, `x^2` ser√° una matriz.

Hay valores opcionales y kwargs, ambas tienen caracter√≠sticas diferentes:
```{julia}
function f(x, t=1)
    (x+t)^2
end

function g(x; t=1)
    (x+t)^2
end
```

## Definici√≥n de estructuras

```{julia}
struct Point
  x::Float32
  y::Float32
end
```

La idea suele ser que todo se use de manera armoniosa
```{julia}
"""
  Calcula la norma de un vector representado
  como un tupla
"""
function norm(u::Tuple)
  s = 0f0

  for i in eachindex(u)
    s += u[i]^2
  end

  sqrt(s)
end

"""
  Calcula la norma de un vector de 2 dimensiones
  representado como una estructura
"""
function norm(u::Point)
  sqrt(u.x^2 + u.y^2)
end

(norm((1, 1, 1, 1)), norm(Point(1, 1)))
```

## Arreglos
Una matriz aleatoria de $4 \times 6$ se define como sigue
```{julia}
A = rand(Float32, 4, 6)
```

Un vector aleatorio de 6 dimensiones ser√≠a como sigue:

```{julia}
x = rand(Float32, 4)
```

entonces podriamos multiplicar `x` con `A` como sigue:
```{julia}
y = x' * A
```

```{julia}
y'
```

Tambi√©n existen otras formas para realizarla, aunque no suelen ser la mejor idea si se tienen alternativas can√≥nicas:

```{julia}
using LinearAlgebra

dot.(Ref(x), eachcol(A))
```

Este ejemplo muestra la t√©cnica _broadcasting_ que aplica una funci√≥n a una colecci√≥n; se indica a√±adiendo un punto al final del nombre de la funci√≥n. Adicionalmente, hay una serie de reglas que se deben seguir para el manejo de las colecciones. La funci√≥n `eachcol` crea un iterador sobre cada columna de la matriz `A` y `Ref(x)`, nos permite que el `broadcasting` reconozca al vector `x` como un √∫nico elemento en lugar de una colecci√≥n de valores.

## Paquetes y m√≥dulos
El ecosistema de paquetes de Julia es una de sus mayores fortalezas, impulsado por usu gestor de paquetes _Pkg_, el cual viene integrado en el REPL y en la su instalaci√≥n m√≠nima; es muy robusto. Se encarga de la instalaci√≥n y actualizaci√≥n de librer√≠as, as√≠ como tambi√©n garantiza la reproducibilidad de los proyectos. Cada ambiente de trabajo en Julia utiliza archivos como `Project.toml` y `Manifest.toml` para registrar la paqueter√≠a usada, as√≠ como las versiones necesarias de todas las dependencias. 

### Pkg en REPL

Para entrar al modo Pkg desde cualquier sesi√≥n de Julia en el REPL se debe teclear corchete que cierra `]`.


El prompt del REPL cambiar√°:

| Modo | Prompt |
| :--- | :--- |
| Normal (Julia) | ` julia>  ` |
| _Modo Pkg_ | ` (@v1.10) pkg>  ` |


Ahora se puede ver qu√© paquetes est√°n instalados en tu entorno actual.

| Comando | Acci√≥n |
| :--- | :--- |
| `st` o `status` | Muestra la lista de todos los paquetes instalados y sus versiones espec√≠ficas. |

Para a√±adir una _paquete_ a tu entorno, usa el comando `add`.

| Comando | Acci√≥n |
| :--- | :--- |
| `add Paquete` | Descarga e instala el paquete. |

En el caso de que un paquete ya no sea necesario, se puede desinstalar con el comando `rm` (de _remove_).

| Comando | Acci√≥n |
| :--- | :--- |
| `rm Paquete` | Elimina el paquete del entorno actual. |


Finalmente, es posible actualizar paquetes de manera individual o colectiva usando el comando `up`.

| Comando | Acci√≥n |
| :--- | :--- |
| `up` o `update` | _Actualiza_ todos los paquetes instalados a su √∫ltima versi√≥n compatible. |
| `up Paquete` o `update Paquete` | Actualiza `Paquete` a su √∫ltima versi√≥n compatible. |

#### Manejo de ambientes 
El entorno o ambiente (_environment_) se puede especificar de manera global o por diretorio, y nos sirve para aislar las aplicaciones y no entrar en dificultades por versiones.

| Comando | Acci√≥n |
| :--- | :--- |
| `activate dir`  | Activa el directorio `dir` como ambiente. |

Supongamos que nos comparten un proyecto escrito en julia, lo primero que debemos hacer es activar e instanciar el ambiente; la instanciaci√≥n es como sigue

| Comando | Acci√≥n |
| :--- | :--- |
| `instantiate`  | Se instalan todos los paquetes indicados por el ambiente. |

Muchas veces tambi√©n cambiamos paquetes locales que requiren reactualizar el ambiente, eso se consigue con `] resolve` que actualizar√° las nuevas dependencias que cambiaron.

#### Saliendo del modo Pkg
Para volver al modo de ejecuci√≥n de c√≥digo normal de Julia, se debe presionar _backspace_.

El prompt cambiar√° de nuevo a `julia>` y podr√°s usar los paquetes que instalaste con el comando `using`.

```julia
using DataFrames, CSV

```

esto traera el paquete al entorno en memoria haciendo accesibles sus m√©todos y estructuras p√∫blicas.

### Usando `Pkg` desde el modo normal de Julia (fuera del modo Pkg del REPL)

Existe un paquete interno de las instalaciones de julia llamado `Pkg` que es el que maneja todo lo anterior, este puede ser utilizado como cualquier paquete. Basicamente tiene funciones similares a las del modo `Pkg` (con nombres completos).

Ejemplos:

```julia
julia> import Pkg
julia> Pkg.add("PlotlyLight") 
julia> Pkg.add(["CSV", "DataFrames"]) 
julia> Pkg.rm("PlotlyLight")
julia> Pkg.update()
julia> Pkg.status() 
```

Ahora para el manejo de los ambientes:

```julia
julia> import Pkg
julia> Pkg.activate(".")
julia> Pkg.instantiate()
julia> Pkg.add("Statistics")
```

## Otras estrategias para la organizaci√≥n de c√≥digo

La funci√≥n `include("nombre_archivo.jl")` es el m√©todo m√°s simple en Julia para organizar c√≥digo en m√∫ltiples archivos. Su funci√≥n es equivalente a _copiar y pegar_ el contenido del archivo especificado directamente en la l√≠nea donde se llama a `include`.

Sirve para estructurar grandes *scripts* en archivos m√°s peque√±os y manejables; el c√≥digo incluido se ejecuta en el mismo _alcance_ (scope) donde se llam√≥ a `include`. Si llamas a `include` en el alcance global, las funciones y variables definidas en el archivo incluido se vuelven globales. Si lo llamas dentro de un m√≥dulo, se vuelven parte de ese m√≥dulo.

Es simple, pero no proporciona aislamiento, y puede generar conflictos de nombres si no se usa de manera adecuada.

Por otro lado, los _m√≥dulos_ permmiten crear *espacios de nombres (namespaces)* aislados y bien definidos, utiles para organizar proyectos grandes y complejos.

### Aislamiento y alcance (Scoping)

Un m√≥dulo act√∫a como una _caja_ que encierra sus funciones y variables. Todo lo que se define dentro de un m√≥dulo es _privado_ por defecto para evitar conflictos de nombres con c√≥digo externo.

```julia
module MiCalculadora
    # Esta funci√≥n es PRIVADA
    function interna(x)
        return x * 2
    end

    # Esta funci√≥n se hace P√öBLICA con 'export'
    export sumar

    function sumar(a, b)
        return a + b
    end
end
```

Para que las funciones, tipos o constantes dentro de un m√≥dulo sean accesibles desde afuera, deben ser expl√≠citamente *exportadas* utilizando la palabra clave `export`.

Los modulos pueden anidarse.

Para utilizar las funciones de un m√≥dulo en otro script o en el REPL, se usan dos comandos principales:

| Comando | Acci√≥n |
| :--- | :--- |
| **`using NombreModulo`** | Importa solo los s√≠mbolos que han sido **exportados** por el m√≥dulo. |
| **`import NombreModulo`** | Importa el m√≥dulo completo. Para usar sus funciones, debes prefijarlas (ej: `NombreModulo.sumar(1, 2)`). |

En la pr√°ctica, un paquete o un proyecto grande de Julia casi siempre usa tanto `include` como m√≥dulos. De esta manera, `include` ayuda a la organizaci√≥n de archivos, mientras que el bloque `module` garantiza que todo el c√≥digo est√© contenido en un espacio de nombres √∫nico y limpio, evitando colisiones.

En particular, los _paquetes_ pueden verse como la preparaci√≥n de un m√≥dulo para su distribuci√≥n, indicando los paquetes que usan (dependencias) y sus versiones especificas para los cuales fueron dise√±ados. Tambi√©n suelen incluir documentaci√≥n y pruebas unitarias. 


## Recursos para aprender m√°s sobre el lenguaje

- Informaci√≥n sobre como instalar Julia y flujos de trabajo simples (e.g., REPL, editores, etc.) para trabajar con este lenguaje de programaci√≥n: _Modern Julia Workflows_ <https://modernjuliaworkflows.github.io/>.
- Libro sobre julia _Think Julia: How to Think Like a Computer Scientist_ <https://benlauwens.github.io/ThinkJulia.jl/latest/book.html>.
- Curso _Introduction to computational thinking_ <https://computationalthinking.mit.edu/Fall20/>


