[
  {
    "objectID": "01-intro.html",
    "href": "01-intro.html",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "",
    "text": "1.1 Instalaci√≥n\nEl c√≥digo se organiza en scripts, m√≥dulos y paquetes. Cada uno de estos define tipos y funciones que interactuan para componer las soluciones deseadas.\nEl resto de esta unidad esta dedicada a precisar la sintaxis del lenguaje y anotaciones de importancia sobre su funcionamiento.\nEl sitio oficial recomienda el uso de juliaup, una herramienta que permite manejar diferentes versiones de Julia y mantenerlas actualizarlas.\nhttps://julialang.org/install/\nLas versiones de Julia siguen el paradigma de semantic versioning (semver), por lo que juliaup permite gestionarlas de manera simple y efectiva. La versi√≥n estable es la 1.10 y las m√°s nuevas son la 1.11 y la 1.12.\nTambi√©n es posible usar Colab de Google con el kernel para Julia; este usar julia 1.11 y hasta el momento, es el √∫nico disponible.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "01-intro.html#el-lenguaje-de-programaci√≥n-julia",
    "href": "01-intro.html#el-lenguaje-de-programaci√≥n-julia",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "",
    "text": "1.1.1 Funciones\nLas funciones son centrales en Julia, y son definidas mediante la sintaxis\n```{julia}\n1function fun(arg1, arg2...)\n    # ... expresiones ...\nend\n\n2function fun(arg1, arg2...; kwarg1=valor1, kwargs2...)\n    # ... expresiones ...\nend\n\n3fun(arg1, arg2...; kwarg1=valor1, kwargs2...) = expresion\n\n4(arg1, arg2...; kwarg1=valor1, kwargs2...) -&gt; expresion\n\n5fun() do x\n    x^2 # ... expresiones ...\nend\n```\n\n1\n\nDefinici√≥n de una funci√≥n simple, los tipos de los argumentos se utilizan para generar m√∫ltiples versiones de una funci√≥n.\n\n2\n\nTambi√©n se soportan argumentos nombrados, los cuales van despu√©s de ;, se debe tener en cuenta que los tipos de los argumentos nombrados no son utilizados para determinar si una funci√≥n debe compilarse. Los argumentos nombrados pueden o no tener valores por omisi√≥n.\n\n3\n\nSi la funci√≥n tiene una estructura simple, de una expresi√≥n, es posible ignorar function y end, usando ‚Äò=‚Äô para definirla.\n\n4\n\nMuchas veces es √∫til definir funciones an√≥nimas, que suelen pasarse a otras funciones de orden superior.\n\n5\n\nUn embellecedor √∫til para generar una funci√≥n an√≥nima (definida entre do...end) que se pasa como primer argumento a fun, e.g., es equivalente a fun(x-&gt;x^2).\n\n\nEl √°mbito o scope de las variables en Julia es sint√°ctico, que significa que se hereda del c√≥digo donde las funciones fueron definidas, y no din√°mico (que se hereda desde d√≥nde se ejecuta la funci√≥n). Aunque es el comportamiento de la mayor√≠a de los lenguajes modernos, es importante conocerlo sobre todo para la creaci√≥n de cerraduras sint√°cticas en funciones.\nUna funci√≥n se ejecuta con la sintaxis nombre(arg1...). Conviene profundizar en las expresiones y dem√°s componentes del lenguaje antes del ir a m√°s ejemplos sobre funciones.\n\n\n1.1.2 Hola mundo\nUno de los programas m√°s comunes es el siguiente\n\nprintln(\"¬°Hola üåé!\")\n\n¬°Hola üåé!\n\n\n\n\n1.1.3 Expresiones y operadores\nLas expresiones son la forma m√°s gen√©rica de expresar el c√≥digo en Julia, comprenden operaciones aritm√©ticas, asignaci√≥n y declaraci√≥n de variables, definiciones de bloques de c√≥digo, llamadas de funciones, entre otras.\nCada linea suele ser una expresi√≥n, a menos que se extienda por m√∫ltiples lineas por medio de un agrupador de c√≥digo o datos, estos pueden ser begin...end, let...end, (...), [...], [...], for...end, while...end, if...end, function...end, try...end, entre las m√°s utilizadas.\nLas definiciones de variables tienen la sintaxis variable = valor; las variables comunmente comienzan con una letra o _, las letras pueden ser caracteres unicode, no deben contener espacios ni puntuaciones como parte del nombre; valor es el resultado de evaluar o ejecutar una expresi√≥n.\nLos operadores m√°s comunes son los aritm√©ticos +, -, *, /, √∑, %, \\, ^, con precedencia y significado t√≠pico. Existen maneras compuestas de modificar una variable anteponiendo el operador aritm√©tico al simbolo de asignaci√≥n, e.g., variable += valor, que se expande a variable = variable + valor. Esto implica que variable debe estar previamente definida previo a la ejecuci√≥n.\nLos operadores l√≥gicos tambi√©n tienen el significado esperado.\n\n\n\noperaci√≥n\ndescripci√≥n\n\n\n\n\na && b\nAND l√≥gico\n\n\na || b\nOR l√≥gico\n\n\na ‚äª b\nXOR l√≥gico\n\n\n!a\nnegaci√≥n l√≥gica\n\n\na &lt; b\ncomparaci√≥n a es menor que b\n\n\na &gt; b\ncomparaci√≥n a es mayor que b\n\n\na &lt;= b\ncomparaci√≥n a es menor o igual que b\n\n\na &gt;= b\ncomparaci√≥n a es mayor o igual que b\n\n\na == b\ncomparaci√≥n de igualdad\n\n\na === b\ncomparaci√≥n de igualdad (a nivel de tipo)\n\n\na != b\ncomparaci√≥n de desigualdad\n\n\na !== b\ncomparaci√≥n de desigualdad (a nivel de tipo)\n\n\n\nEn particular && y || implementan corto circuito de c√≥digo, por lo que pueden usarse para el control de que operaciones se ejecutan. Cuando se compara a nivel de tipo 0 (entero) ser√° diferente de 0.0 (real).\nTambi√©n hay operadores l√≥gicos a nivel de bit, los argumentos son enteros.\n\n\n\noperaci√≥n\ndescripci√≥n\n\n\n\n\na & b\nAND a nivel de bits\n\n\na | b\nOR a nivel de bits\n\n\na ‚äª b\nXOR a nivel del bits\n\n\n~a\nnegaci√≥n l√≥gica a nivel de bits\n\n\n\n\n\n1.1.4 Literales\nDado que existen m√∫ltiples tipos de datos existen diferentes formas de definirlas; una de ellas, probablemente la que m√°s estaremos usando son los literales, es decir, escribir los datos directamente en el c√≥digo.\nLos n√∫meros enteros se definen sin punto decimal, es posible usar _ como separador y dar m√°s claridad al c√≥digo. Los enteros pueden tener 8, 16, 32, o 64 bits; por omisi√≥n, se empaquetan en variables del tipo Int (Int64). Los valores hexadecimales se interpretan como enteros sin signo, y adem√°s se empaquetan al n√∫mero de bits necesario minimo para contener. El comportamiento para valores en base 10 es el de hexadecimal es congruente con un lenguaje para programaci√≥n de sistemas.\n\na = 100\nprintln((a, sizeof(a)))\nb = Int8(100)\nprintln((b, sizeof(b)))\nc = 30_000_000\nprintln((c, sizeof(c)))\nd = 0xffff\nprintln((d, sizeof(d)))\n\n(100, 8)\n(100, 1)\n(30000000, 8)\n(0xffff, 2)\n\n\n\n\nExisten n√∫meros enteros de precisi√≥n 128 pero las operaciones al d√≠a de hoy no son implementadas de manera nativa por los procesadores; as√≠ mismo se reconocen n√∫meros de punto flotante de precisi√≥n media Float16 pero la mayor√≠a de los procesadores no tienen soporte nativo para realizar operaciones con ellos, aunque los procesadores de √∫ltima generaci√≥n si lo tienen.\nSi la precisi√≥n esta en duda o el contexto lo am√©rita, deber√° especificarlo usando el constructor del tipo e.g., Int8(100), UInt8(100), Int16(100), UInt16(100), Int32(100), UInt32(100), Int64(100), UInt64(100).\nLos n√∫meros de punto flotante tienen diferentes formas de definirse, teniendo diferentes efectos. Para n√∫meros de precision simple, 32 bits, se definen con el sufijo f0 como 3f0. El sufijo e0 tambi√©n se puede usar para definir precisi√≥n doble (64 bit). El cero del sufijo en realidad tiene el objetivo de colocar el punto decimal, en notaci√≥n de ingenier√≠a, e.g., \\(0.003\\) se define como \\(3f-3\\) o \\(3e-3\\), dependiendo del tipo de dato que se necesite. Si se omite sufijo y se pone solo punto decimal entonces se interpretar√° como precision doble. Los tipos son Float32 y Float64.\nLos datos booleanos se indican mediante true y false para verdadero y falso, respectivamente.\nLos caracteres son s√≠mbolos para √≠ndicar cadenas, se suelen representar como enteros peque√±os en memoria. Se especifican con comillas simples 'a', 'z', '!' y soporta simbolos unicode 'ü§†'.\nLas cadenas de caracteres son la manera de representar textos como datos, se guardan en zonas contiguas de memoria. Se especifican con comillas dobles y tambi√©n soportan s√≠mbolos unicode, e.g., \"hola mundo\", \"pato es un üê∑\".\n\n\nJulia guarda los simbolos de manera especial y pueden ser utilizados para realizar identificaci√≥n de datos eficiente, sin embargo, no es buena idea saturar el sistema de manejo de s√≠mbolos por ejemplo para crear un vocabulario ya que no liberar√° la memoria despu√©s de definirlos ya que es un mec√°nismo dise√±ado para la representaci√≥n de los programas, pero lo suficientemente robusto y bien definido para usarse en el dise√±o e implementaci√≥n de programas de los usuarios.\nEn Julia existe la noci√≥n de s√≠mbolo, que es una cadena que adem√°s solo existe en una posici√≥n en memoria se usa el prefijo : para denotarlos.\n\nprintln(:hola === :hola)\nprintln(typeof(:hola))\nprintln(Symbol(\"hola mundo\"))\n\ntrue\nSymbol\nhola mundo\n\n\n\n\n1.1.5 Control de flujo\nEl control de flujo nos permite escoger que partes del c√≥digo se ejecutaran como consecuencia de la evaluaci√≥n de una expresi√≥n, esto incluye repeticiones.\nLas condicionales son el control de flujo m√°s simple.\n\na = 10\n1if a % 2 == 0\n2    \"par\"\nelse\n3    \"impar\"\nend\n\n\n1\n\nExpresi√≥n condicional.\n\n2\n\nExpresi√≥n a ejecutarse si (1) es verdadero.\n\n3\n\nExpresi√≥n a evaluarse si (1) es falso.\n\n\n\n\n\"par\"\n\n\nSe puede ignorar la clausula else dando solo la opci√≥n de evaluar (2) si (1) es verdadero. Finalmente, note que la condicional es una expresi√≥n y devuelve un valor.\n\na = 10\nif log10(a) == 1\n    \"es 10\"\nend\n\n\"es 10\"\n\n\nTambi√©n pueden concatenarse m√∫ltiples expresiones condicionales con elseif como se muestra a continuaci√≥n.\n\na = 9\nif a % 2 == 0\n    println(\"divisible entre 2\")\nelseif a % 3 == 0\n    println(\"divisible entre 3\")\nelse\n    println(\"no divisible entre 2 y 3\")\nend\n\ndivisible entre 3\n\n\nEs com√∫n utilizar la sintaxis en Julia (short circuit) para control de flujo:\n\na = 9\n\n1println(a % 2 == 0 && \"es divisible entre dos\")\n2println(a % 3 == 0 && \"es divisible entre tres\")\n\n\n1\n\nEl resultado de la condici√≥n es falso, por lo que no se ejecutar√° la siguiente expresi√≥n.\n\n2\n\nEl resultado es verdadero, por lo que se ejecutar√° la segunda expresi√≥n.\n\n\n\n\nfalse\nes divisible entre tres\n\n\nFnalmente, existe una condicional de tres vias expresion ? expr-verdadero : expr-falso\n\na = 9\n\nprintln(a % 2 == 0 ? \"es divisible entre dos\" : \"no es divisible entre dos\")\nprintln(a % 3 == 0 ? \"es divisible entre tres\" : \"no es divisible entre tres\")\n\nno es divisible entre dos\nes divisible entre tres\n\n\n\n1.1.5.1 Ciclos\nLos ciclos son expresiones de control de flujo que nos permiten iterar sobre una colecci√≥n o repetir un c√≥digo hasta que se cumpla alguna condici√≥n. En Julia existen dos expresiones de ciclos:\n\nfor x in colecci√≥n ...expresiones... end y\nwhile condici√≥n ...expresioens... end\n\nEn el caso de for, la idea es iterar sobre una colecci√≥n, esta colecci√≥n puede ser un rango, i.e., inicio:fin, inicio:paso:fin, o una colecci√≥n como las tuplas, los arreglos, o cualquiera que cumpla con la interfaz de colecci√≥n iterable del lenguaje.\n\nfor i in 1:5\n    println(\"1er ciclo: \", i =&gt; i^2)\nend\n\nfor i in [10, 20, 30, 40, 50]\n    println(\"2do ciclo: \", i =&gt; i/10)\nend\n\n1er ciclo: 1 =&gt; 1\n1er ciclo: 2 =&gt; 4\n1er ciclo: 3 =&gt; 9\n1er ciclo: 4 =&gt; 16\n1er ciclo: 5 =&gt; 25\n2do ciclo: 10 =&gt; 1.0\n2do ciclo: 20 =&gt; 2.0\n2do ciclo: 30 =&gt; 3.0\n2do ciclo: 40 =&gt; 4.0\n2do ciclo: 50 =&gt; 5.0\n\n\nAl igual que en otros lenguajes modernos, se define la variante completa o comprehensive for que se utiliza para transformar la colecci√≥n de entrada en otra colecci√≥n cuya sintaxis se ejemplifica a continuaci√≥n:\n\na = [i =&gt; i^2 for i in 1:5]\nprintln(a)\n\n[1 =&gt; 1, 2 =&gt; 4, 3 =&gt; 9, 4 =&gt; 16, 5 =&gt; 25]\n\n\nTambi√©n es posible definir un generador, esto es, un c√≥digo que puede generar los datos, pero que no los generar√° hasta que se les solicite.\n\na = (i =&gt; i^2 for i in 1:5)\nprintln(a)\nprintln(collect(a))\n\nBase.Generator{UnitRange{Int64}, var\"#3#4\"}(var\"#3#4\"(), 1:5)\n[1 =&gt; 1, 2 =&gt; 4, 3 =&gt; 9, 4 =&gt; 16, 5 =&gt; 25]\n\n\nOtra forma de hacer ciclos de intrucciones es repetir mientras se cumpla una condici√≥n:\n\ni = 0\nwhile i &lt; 5\n    i += 1\n    println(i)\nend\n\ni\n\n1\n2\n3\n4\n5\n\n\n5\n\n\n\n\n\n1.1.6 Tuplas y arreglos en Julia\nUna tupla es un conjunto ordenado de datos que no se puede modificar y que se desea esten contiguos en memoria, la sintaxis en memoria es como sigue:\n\n1a = (2, 3, 5, 7)\nb = (10, 20.0, 30f0)\nc = 100 =&gt; 200\n2println(typeof(a))\nprintln(typeof(b))\nprintln(typeof(c))\n3a[1], a[end], b[3], c.first, c.second\n\n\n1\n\nDefine las tuplas.\n\n2\n\nImprime los tipos de las tuplas.\n\n3\n\nMuestra como se accede a los elementos de las tuplas. Julia indexa comenzando desde 1, y el t√©rmino end tambi√©n se utiliza para indicar el √∫ltimo elemento en una colecci√≥n ordenada.\n\n\n\n\nNTuple{4, Int64}\nTuple{Int64, Float64, Float32}\nPair{Int64, Int64}\n\n\n(2, 7, 30.0f0, 100, 200)\n\n\nLa misma sintaxis puede generar diferentes tipos de tuplas. En el caso NTuple{4, Int4} nos indica que el tipo maneja cuatro elementos de enteros de 64 bits, los argumentos entre {} son parametros que especifican los tipos en cuesti√≥n. En el caso de Tuple se pueden tener diferentes tipos de elementos. La tupla Pair es especial ya que solo puede contener dos elementos y es b√°sicamente para embellecer o simplificar las expresiones; incluso se crea con la sintaxis key =&gt; value y sus elementos pueden accederse mediante dos campos nombrados.\nLos arreglos son datos del mismo tipo contiguos en memoria, a diferencia de las tuplas, los elementos se pueden modificar, incluso pueden crecer o reducirse. Esto puede implicar que se alojan en zonas de memoria diferente (las tuplas se colocan en el stack y los arreglos en el heap, ver la siguiente unidad para m√°s informaci√≥n). Desde un alto nivel, los arreglos en Julia suelen estar asociados con vectores, matrices y tensores, y un arsenal de funciones relacionadas se encuentran definidas en el paquete LinearAlgebra, lo cual esta m√°s all√° del alcance de este curso.\n\n1a = [2, 3, 5, 7]\nb = [10, 20.0, 30f0]\n2println(typeof(a))\nprintln(typeof(b))\n3a[1], a[end], b[3], b[2:3]\n\n\n1\n\nDefine los arreglos a y b.\n\n2\n\nMuestra los tipos de los arreglos, note como los tipos se promueven al tipo m√°s g√©nerico que contiene la definici√≥n de los datos.\n\n3\n\nEl acceso es muy similar a las tuplas para arreglos unidimensionales, note que es posible acceder rangos de elementos con la sintaxis ini:fin.\n\n\n\n\nVector{Int64}\nVector{Float64}\n\n\n(2, 7, 30.0, [20.0, 30.0])\n\n\n\na = [2 3;\n1     5 7]\n2display(a)\n3display(a[:, 1])\n4display(a[1, :])\n\n\n1\n\nDefinici√≥n de un arreglo bidimensional, note como se ignora la coma , en favor de la escritura por filas separadas por ;.\n\n2\n\nLa variable a es una matriz de 2x2.\n\n3\n\nEs posible acceder una columna completa usando el s√≠mbolo : para indicar todos los elementos.\n\n4\n\nDe igual forma, es posible acceder una fila completa.\n\n\n\n\n2√ó2 Matrix{Int64}:\n 2  3\n 5  7\n\n\n2-element Vector{Int64}:\n 2\n 5\n\n\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n1.1.7 Diccionarios y conjuntos en Julia\nUn diccionario es un arreglo asociativo, i.e., guarda pares llave-valor. Permite acceder de manera eficiciente al valor por medio de la llave, as√≠ como tambi√©n verificar si hay una entrada dentro del diccionario con una llave dada. La sintaxis es como sigue:\n\n1a = Dict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 3)\n2a[:b] = 20\nprintln(a)\n3a[:d] = 4\nprintln(a)\n4delete!(a, :a)\na\n\n\n1\n\nDefinici√≥n del diccionario a que mapea simbolos a enteros.\n\n2\n\nCambia el valor de :b por 20.\n\n3\n\nA√±ade :d =&gt; 4 al diccionario a.\n\n4\n\nBorra el par con llave :a.\n\n\n\n\nDict(:a =&gt; 1, :b =&gt; 20, :c =&gt; 3)\nDict(:a =&gt; 1, :b =&gt; 20, :d =&gt; 4, :c =&gt; 3)\n\n\nDict{Symbol, Int64} with 3 entries:\n  :b =&gt; 20\n  :d =&gt; 4\n  :c =&gt; 3\n\n\nEs posible utilizar diferentes tipos siempre y cuando el tipo en cuesti√≥n defina de manera correcta la funci√≥n hash sobre la llave y la verificaci√≥n de igualdad ==.\nUn conjunto se representa con el tipo Set, se implementa de manera muy similar al diccionario pero solo necesita el elemento (e.g., la llave). Como conjunto implementa las operaciones clasificaci√≥n de operaciones de conjuntos\n\n1a = Set([10, 20, 30, 40])\n2println(20 in a)\n3push!(a, 50)\nprintln(a)\n4delete!(a, 10)\nprintln(a)\n5println(intersect(a, [20, 35]))\n6union!(a, [100, 200])\nprintln(a)\n\n\n1\n\nDefinici√≥n del conjunto de n√∫meros enteros.\n\n2\n\nVerificaci√≥n de membresia al conjunto a.\n\n3\n\nA√±ade 50 al conjunto.\n\n4\n\nSe borra el elemento 10 del conjunto.\n\n5\n\nIntersecci√≥n de a con una colecci√≥n, no se modifica el conjunto a.\n\n6\n\nUni√≥n con otra colecci√≥n, se modifica a.\n\n\n\n\ntrue\nSet([50, 20, 10, 30, 40])\nSet([50, 20, 30, 40])\nSet([20])\nSet([50, 200, 20, 30, 40, 100])",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "01-intro.html#el-flujo-de-compilaci√≥n-de-julia",
    "href": "01-intro.html#el-flujo-de-compilaci√≥n-de-julia",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "1.3 El flujo de compilaci√≥n de Julia",
    "text": "1.3 El flujo de compilaci√≥n de Julia\nBasta con escribir una linea de c√≥digo en el REPL de Julia y esta se compilar√° y ejecutar√° en el contexto actual, usando el √°mbito de variables. Esto es conveniente para comenzar a trabajar, sin embargo, es importante conocer el flujo de compilaci√≥n para tenerlo en cuenta mientras se c√≥difica, y as√≠ generar c√≥digo eficiente. En particular, la creaci√≥n de funciones y evitar la inestabilidad de los tipos de las variables es un paso hacia la generaci√≥n de c√≥digo eficiente. Tambi√©n es importante evitar el alojamiento de memoria din√°mica siempre que sea posible. A continuaci√≥n se mostrar√° el an√°lisis de un c√≥digo simple a diferentes niveles, mostrando que el lenguaje nos permite observar la generaci√≥n de c√≥digo, que √∫ltimadamente nos da cierto control y nos permite verificar que lo que se esta implementando es lo que se espec√≠fica en el c√≥digo. Esto no es posible en lenguajes como Python.\n\nlet\n    e = 1.1\n    println(e*e)\n    @code_typed e*e\nend\n\n1.2100000000000002\n\n\nCodeInfo(\n1 ‚îÄ %1 = Base.mul_float(x, y)::Float64\n‚îî‚îÄ‚îÄ      return %1\n) =&gt; Float64\n\n\nEn este c√≥digo, se utiliza la estructa de agrupaci√≥n de expresiones let...end. Cada expresi√≥n puede estar compuesta de otras expresiones, y casi todo es una expresi√≥n en Julia. La mayoria de las expresiones ser√°n finalizadas por un salto de linea, pero las compuestas como let, begin, function, if, while, for, do, module estar√°n finalizadas con end. La indentaci√≥n no importa la indentaci√≥n como en Python, pero es aconsejable para mantener la legibilidad del c√≥digo. La linea 2 define e inicializa la variable e; la linea 3 llama a la funci√≥n println, que imprimir√° el resultado de e*e en la consola. La funci√≥n println esta dentro de la biblioteca est√°ndar de Julia y siempre esta visible. La linea 4 es un tanto diferente, es una macro que toma la expresi√≥n e*e y realiza algo sobre la expresi√≥n misma, en particular @code_type muestra como se reescribe la expresi√≥n para ser ejecutada. Note como se har√° una llamada a la funci√≥n Base.mul_float que recibe dos argumentos y que regresar√° un valor Float64. Esta informaci√≥n es necesaria para que Julia pueda generar un c√≥digo veloz, el flujo de compilaci√≥n llevar√≠a esta informaci√≥n a generar un c√≥digo intermedio de Low Level Virtual Machine (LLVM), que es el compilador empotrado en Julia, el cual estar√≠a generando el siguiente c√≥digo LLVM (usando la macro @code_llvm):\n\n\n;  @ float.jl:411 within `*`\ndefine double @\"julia_*_1805\"(double %0, double %1) #0 {\ntop:\n  %2 = fmul double %0, %1\n  ret double %2\n}\n\n\nEste c√≥digo ya no es espec√≠fico para Julia, sino para la maquinar√≠a LLVM. Observe la especificidad de los tipos y lo corto del c√≥digo. El flujo de compilaci√≥n requerir√≠a generar el c√≥digo nativo, que puede ser observado a continuaci√≥n mediante la macro @code_native:\n\n\n    .text\n    .file   \"*\"\n    .globl  \"julia_*_1844\"                  # -- Begin function julia_*_1844\n    .p2align    4, 0x90\n    .type   \"julia_*_1844\",@function\n\"julia_*_1844\":                         # @\"julia_*_1844\"\n; ‚îå @ float.jl:411 within `*`\n# %bb.0:                                # %top\n    push    rbp\n    mov rbp, rsp\n    vmulsd  xmm0, xmm0, xmm1\n    pop rbp\n    ret\n.Lfunc_end0:\n    .size   \"julia_*_1844\", .Lfunc_end0-\"julia_*_1844\"\n; ‚îî\n                                        # -- End function\n    .section    \".note.GNU-stack\",\"\",@progbits\n\n\nEn este caso podemos observar c√≥digo espec√≠fico para la computadora que esta generando este documento, es posible ver el manejo de registros y el uso de instrucciones del CPU en cuesti√≥n.\nEste c√≥digo puede ser eficiente dado que los tipos y las operaciones son conocidos, en el caso que esto no puede ser, la eficiencia esta perdida. Datos no nativos o la imposibilidad de determinar un tipo causar√≠an que se generar√° m√°s c√≥digo nativo que terminar√≠a necesitanto m√°s recursos del procesador. Una situaci√≥n similar ocurre cuando se aloja memoria de manera din√°mica. Siempre estaremos buscando que nuestro c√≥digo pueda determinar el tipo de datos para que el c√≥digo generado sea simple, si es posible usar datos nativos, adem√°s de no manejar o reducir el uso de memor√≠a din√°mica.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "01-intro.html#ejemplos-de-funciones",
    "href": "01-intro.html#ejemplos-de-funciones",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "1.4 Ejemplos de funciones",
    "text": "1.4 Ejemplos de funciones\nLas funciones ser√°n una parte central de nuestros ejemplos, por lo que vale la pena retomarlas y dar ejemplos.\n\nfunction f(x)\n    x^2\nend\n\nf (generic function with 1 method)\n\n\nSiempre regresan el valor de la √∫ltima expresi√≥n; note como el tipo (y no solo el valor) de retorno depende del tipo de la entrada, e.g., si x es un entero entonces x^2 ser√° un entero, pero si x es una matriz, x^2 ser√° una matriz.\nHay valores opcionales y kwargs, ambas tienen caracter√≠sticas diferentes:\n\nfunction f(x, t=1)\n    (x+t)^2\nend\n\nfunction g(x; t=1)\n    (x+t)^2\nend\n\ng (generic function with 1 method)",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "01-intro.html#recursos-para-aprender-python-y-julia",
    "href": "01-intro.html#recursos-para-aprender-python-y-julia",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "1.8 Recursos para aprender Python y Julia",
    "text": "1.8 Recursos para aprender Python y Julia\n\n1.8.1 Julia\n\nInformaci√≥n sobre como instalar Julia y flujos de trabajo simples (e.g., REPL, editores, etc.) para trabajar con este lenguaje de programaci√≥n: Modern Julia Workflows https://modernjuliaworkflows.github.io/.\nLibro sobre julia Think Julia: How to Think Like a Computer Scientist https://benlauwens.github.io/ThinkJulia.jl/latest/book.html.\nCurso Introduction to computational thinking https://computationalthinking.mit.edu/Fall20/",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "01-intro.html#licencia",
    "href": "01-intro.html#licencia",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "1.10 Licencia",
    "text": "1.10 Licencia\n\nEsta obra est√° bajo una Licencia Creative Commons Atribuci√≥n-CompartirIgual 4.0 Internacional",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "01-intro.html#footnotes",
    "href": "01-intro.html#footnotes",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "",
    "text": "Para este curso se recomienda utilizar la versi√≥n 1.10 o superior, y puede obtenerse en https://julialang.org/.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso Introductorio al An√°lisis de Algoritmos con Julia",
    "section": "",
    "text": "Prefacio\nEste curso/taller esta dedicado a la Recuperaci√≥n de Informaci√≥n (Information Retrieval) en Julia.1 Nuestro enfoque ser√° experimental, y nuestra metodolog√≠a incluye medir la factibilidad y desempe√±o de cada algoritmo en t√©rminos reales. En particular, Julia es un lenguaje dise√±ado para c√°lculo n√∫merico de alto desempe√±o, aunque adaptado poco a poco para ser utilizado para prop√≥sito general. Por sus caracter√≠sticas es ampliamente usado en investigaci√≥n cient√≠fica y an√°lisis de datos.\nJulia fue dise√±ado para tener una velocidad comparable a lenguajes compilados como C o Fortran. Esto lo logra mediante la compilaci√≥n Just-In-Time (JIT) y una gesti√≥n de memoria eficiente, e.g., intentando evitar el heap a favor del stack. Tiene un dise√±o similar a LISP, ya que es homoic√≥nico y soporta macros que permiten reescribir c√≥digo, y aprovechar el JIT de manera autom√°tica. Soporta la creaci√≥n de binarios y la versi√≥n 1.12, estos binarios se han reducido de tama√±o de manera significativa, lo que permite su uso m√°s extendido.\nEs posible trabajar con m√∫ltiples paradigmas, pero esta dise√±ado para sacar provecho del Despacho M√∫ltiple. Significa que las funciones no solo se definen por su nombre, sino por el tipo de argumentos, y para ser m√°s precisos, de todos sus argumentos. La idea es escribir c√≥digo gen√©rico que es altamente optimizable por el compilador, aunque el costo viene asociado a los tiempos de compilaci√≥n.\nTambi√©n es de tipado din√°mico, pero permite a los programadores agregar anotaciones de tipo a las variables y funciones. Esto no solo mejora el rendimiento del c√≥digo (d√°ndole m√°s informaci√≥n al compilador JIT), sino que tambi√©n facilita la detecci√≥n de errores.\nTiene un ambiente REPL (Read Evaluate Print Loop) que simplifica el proceso de probar c√≥digo e interactuar con el entorno de manera similar a Python o MATLAB. Todas estas caracter√≠stica lo hacen √∫til para prototipar.\nJulia tiene herramientas nativas y de alto nivel para ejecutar c√≥digo en paralelo, ya sea en m√∫ltiples hilos, m√∫ltiples procesos o incluso en clusters distribuidos, lo que es crucial para tareas de gran escala.\nUtiliza un gestor de paquetes (Pkg) integrado que facilita la instalaci√≥n, gesti√≥n de dependencias y la replicaci√≥n de entornos de c√≥digo, asegurando que un proyecto funcione de la misma manera en diferentes m√°quinas.\nFinalmente, es importante mencionar que Julia es un proyecto de c√≥digo abierto, lo que significa que su desarrollo es transparente y est√° impulsado por una comunidad activa de desarrolladores y cient√≠ficos. Funciona en la mayor√≠a de plataformas y sistemas operativos, soporta diversos tipos de Notebooks y Editores; en particular, Visual Studio Code y NeoVim usando AstroNVim tienen ambientes muy bien integrados.\nEste curso esta escrito en Quarto usando el engine para Julia 1.10, se espera que las actividades se repliquen tanto en Quarto https://quarto.org, Jupyter https://jupyter.org/ o Colab. La mayor√≠a de los ejemplos estar√°n empotrados en el sitio, y en principio, deber√≠an poder replicarse copiando, pegando, y ejecutando en un notebook o REPL de Julia.\nEs importante clarificar que este curso introducir√° el lenguaje de programaci√≥n Julia pero habr√° que ir m√°s all√° para dominarlo. Se recomienda al alumno interesado la revisi√≥n del manual y la documentaci√≥n oficial para un estudio m√°s profundo del lenguaje.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#trabajo-en-progreso",
    "href": "index.html#trabajo-en-progreso",
    "title": "Curso Introductorio al An√°lisis de Algoritmos con Julia",
    "section": "Trabajo en progreso",
    "text": "Trabajo en progreso\nEste curso es un trabajo en progreso. Se ha presentado en version extendida como parte de la materia Recuperaci√≥n de Informaci√≥n en Bases de Datos No Estructuradas de la maestr√≠a en Ciencia de Datos e Informaci√≥n de INFOTEC; en esta forma, se pretende dar una introducci√≥n m√°s amena a las aplicaciones.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#licencia",
    "href": "index.html#licencia",
    "title": "Curso Introductorio al An√°lisis de Algoritmos con Julia",
    "section": "Licencia",
    "text": "Licencia\n\nEsta obra est√° bajo una Licencia Creative Commons Atribuci√≥n-CompartirIgual 4.0 Internacional",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Curso Introductorio al An√°lisis de Algoritmos con Julia",
    "section": "",
    "text": "Para este curso se recomienda utilizar la versi√≥n 1.10 o superior, y puede obtenerse en https://julialang.org/.‚Ü©Ô∏é",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "01-intro.html#manos-a-la-obra",
    "href": "01-intro.html#manos-a-la-obra",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "1.2 Manos a la obra",
    "text": "1.2 Manos a la obra\nUna vez instalado, se puede ejecutar un REPL de Julia en la terminal ejecutando\n```{bash}\n$ julia\n```\ndado que instalamos con juliaup podemos mantener diferentes versiones, e.g.,\n```{bash}\n$ juliaup list\n```\nque nos mostrar√° una larga lista de posibles channels o versiones de instalaci√≥n\n```{bash}\n\n$ juliaup add 1.10\n$ juliaup default 1.10\n```\nestas instrucciones a√±adir√°n la versi√≥n 1.10 y la establecer√° como versi√≥n o canal por omisi√≥n. Puedes llamar diferentes versiones ejecutando julia +channel como sigue:\n```{bash}\n$ julia +1.12\n\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.12.1 (2025-10-17)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org release\n|__/                   |\n\njulia&gt;\n\n```\n\n1.2.1 Creando un ‚ÄúHola mundo‚Äù\nUno de los programas m√°s comunes es el siguiente\n\nprintln(\"¬°Hola üåé!\")\n\n¬°Hola üåé!\n\n\n\n\n1.2.2 Usando Colab\nEs posible usar Colab para reducir la complejidad de la instalaci√≥n, ya que cuenta con un kernel de Julia. Como se mencionaba anteriormente, solo se soporta la versi√≥n 1.11 que es suboptima con las versiones de paquetes que usaremos m√°s adelante. Adicionalmente, se tiene limitante de los recursos limitados que se nos proporcionen, en particular al momento de escribir estas notas, aunque los recursos que se otorgan suelen ser suficientes para pruebas, no lo son en otros √°mbitos: solo se tienen 2 vcpus y tiempos de ejecuci√≥n limitados.\n\n\n1.2.3 Usando Jupyter\nUna vez instalado julia; debemos instalar el paquete IJulia que instalar√° todo lo necesario para correr Jupyter (ver la secci√≥n de Pkg al final de esta unidad para m√°s informaci√≥n sobre paquetes). Una vez corriendo, se debe seleccionar crear un notebook espec√≠ficando el kernel de Julia para utilizarlo.\n\n\n1.2.4 Funciones\nLas funciones son centrales en Julia. Por ahora veremos la estructura y m√°s adelante, definiremos algunas.\nPara ejecutar una funci√≥n se utiliza la sintaxis fun(arg), esta regresar√° un valor, que depende de la funci√≥n misma y muchas veces del tipo que tenga arg. Si fueran dos argumentos fun(arg1, arg2), etc. Tambi√©n se soportan argumentos con nombre fun(arg1, arg2, ...; kwarg=val) (kwargs para nombrarlos de manera sint√©tica). En este caso, los kwargs no influyen en los tipos de salida. Esto puede parecer extra√±o pero es debido a las decisiones de implementaci√≥n relacionadas con el desempe√±o.\nLas funciones se definen como sigue:\n1function fun(arg1, arg2...)\n    # ... expresiones ...\nend\n\n2function fun(arg1, arg2...; kwarg1=valor1, kwargs2...)\n    # ... expresiones ...\nend\n\n3fun(arg1, arg2...; kwarg1=valor1, kwargs2...) = expresion\n\n4(arg1, arg2...; kwarg1=valor1, kwargs2...) -&gt; expresion\n\n5fun() do x\n    x^2 # ... expresiones ...\nend\n\n1\n\nDefinici√≥n de una funci√≥n simple, los tipos de los argumentos se utilizan para generar m√∫ltiples versiones de una funci√≥n.\n\n2\n\nTambi√©n se soportan argumentos nombrados, los cuales van despu√©s de ;, se debe tener en cuenta que los tipos de los argumentos nombrados no son utilizados para determinar si una funci√≥n debe compilarse. Los argumentos nombrados pueden o no tener valores por omisi√≥n.\n\n3\n\nSi la funci√≥n tiene una estructura simple, de una expresi√≥n, es posible ignorar function y end, usando ‚Äò=‚Äô para definirla.\n\n4\n\nMuchas veces es √∫til definir funciones an√≥nimas, que suelen pasarse a otras funciones de orden superior.\n\n5\n\nUn embellecedor √∫til para generar una funci√≥n an√≥nima (definida entre do...end) que se pasa como primer argumento a fun, e.g., es equivalente a fun(x-&gt;x^2).\n\n\nEl √°mbito o scope de las variables en Julia es sint√°ctico, que significa que se hereda del c√≥digo donde las funciones fueron definidas, y no din√°mico (que se hereda desde d√≥nde se ejecuta la funci√≥n). Aunque es el comportamiento de la mayor√≠a de los lenguajes modernos, es importante conocerlo sobre todo para la creaci√≥n de cerraduras sint√°cticas en funciones.\n\n\n1.2.5 Expresiones y operadores\nLas expresiones son la forma m√°s gen√©rica de expresar el c√≥digo en Julia, comprenden operaciones aritm√©ticas, asignaci√≥n y declaraci√≥n de variables, definiciones de bloques de c√≥digo, llamadas de funciones, entre otras.\nCada linea suele ser una expresi√≥n, a menos que se extienda por m√∫ltiples lineas por medio de un agrupador de c√≥digo o datos, estos pueden ser\nbegin\n    ...\nend\n\nlet\n    ...\nend\n\n(...)\n\n[...]\n\n[...]\n\nfor elem in collection\n    ...\nend\n\nwhile cond_expr\n    ...\nend\n\nif cond_expr\n    ...\nend\n\nfunction fun(args...; kwargs...)\n    ...\nend\n\ntry\n    ...\ncatch\n    ...\nfinally\n    ...\nend\nentre las m√°s utilizadas; claramentre hay infinidad de formas de componerlas para formar los algoritmos que se esten escribiendo.\n\n1.2.5.1 Definici√≥n de variables\nLas definiciones de variables tienen la sintaxis variable = valor; las variables comunmente comienzan con una letra o _, las letras pueden ser caracteres unicode, no deben contener espacios ni puntuaciones como parte del nombre; valor es el resultado de evaluar o ejecutar una expresi√≥n.\nLos operadores m√°s comunes son los aritm√©ticos +, -, *, /, √∑, %, \\, ^, con precedencia y significado t√≠pico. Existen maneras compuestas de modificar una variable anteponiendo el operador aritm√©tico al simbolo de asignaci√≥n, e.g., variable += valor, que se expande a variable = variable + valor. Esto implica que variable debe estar previamente definida previo a la ejecuci√≥n.\nLos operadores l√≥gicos tambi√©n tienen el significado esperado.\n\n\n\noperaci√≥n\ndescripci√≥n\n\n\n\n\na && b\nAND l√≥gico\n\n\na || b\nOR l√≥gico\n\n\na ‚äª b\nXOR l√≥gico\n\n\n!a\nnegaci√≥n l√≥gica\n\n\na &lt; b\ncomparaci√≥n a es menor que b\n\n\na &gt; b\ncomparaci√≥n a es mayor que b\n\n\na &lt;= b\ncomparaci√≥n a es menor o igual que b\n\n\na &gt;= b\ncomparaci√≥n a es mayor o igual que b\n\n\na == b\ncomparaci√≥n de igualdad\n\n\na === b\ncomparaci√≥n de igualdad (a nivel de tipo)\n\n\na != b\ncomparaci√≥n de desigualdad\n\n\na !== b\ncomparaci√≥n de desigualdad (a nivel de tipo)\n\n\n\nEn particular && y || implementan corto circuito de c√≥digo, por lo que pueden usarse para el control de que operaciones se ejecutan. Cuando se compara a nivel de tipo 0 (entero) ser√° diferente de 0.0 (real).\nTambi√©n hay operadores l√≥gicos a nivel de bit, los argumentos son enteros.\n\n\n\noperaci√≥n\ndescripci√≥n\n\n\n\n\na & b\nAND a nivel de bits\n\n\na | b\nOR a nivel de bits\n\n\na ‚äª b\nXOR a nivel del bits\n\n\n~a\nnegaci√≥n l√≥gica a nivel de bits\n\n\n\n\n\n1.2.5.2 Literales\nLos valores literales son valores explicitos que Julia permite para algunos tipos de datos, y que permiten definirlos de manera simple; permitiendonos escribir datos directamente en el c√≥digo.\nLos n√∫meros enteros se definen sin punto decimal, es posible usar _ como separador y dar m√°s claridad al c√≥digo. Los enteros pueden tener 8, 16, 32, o 64 bits; por omisi√≥n, se empaquetan en variables del tipo Int (Int64). Los valores hexadecimales se interpretan como enteros sin signo, y adem√°s se empaquetan al n√∫mero de bits necesario minimo para contener. El comportamiento para valores en base 10 es el de hexadecimal es congruente con un lenguaje para programaci√≥n de sistemas.\n\na = 100\nprintln((a, sizeof(a)))\nb = Int8(100)\nprintln((b, sizeof(b)))\nc = 30_000_000\nprintln((c, sizeof(c)))\nd = 0xffff\nprintln((d, sizeof(d)))\n\n(100, 8)\n(100, 1)\n(30000000, 8)\n(0xffff, 2)\n\n\n\n\nExisten n√∫meros enteros de precisi√≥n 128 pero las operaciones al d√≠a de hoy no son implementadas de manera nativa por los procesadores; as√≠ mismo se reconocen n√∫meros de punto flotante de precisi√≥n media Float16 pero la mayor√≠a de los procesadores no tienen soporte nativo para realizar operaciones con ellos, aunque los procesadores de √∫ltima generaci√≥n si lo tienen.\nSi la precisi√≥n esta en duda o el contexto lo am√©rita, deber√° especificarlo usando el constructor del tipo e.g., Int8(100), UInt8(100), Int16(100), UInt16(100), Int32(100), UInt32(100), Int64(100), UInt64(100).\nLos n√∫meros de punto flotante tienen diferentes formas de definirse, teniendo diferentes efectos. Para n√∫meros de precision simple, 32 bits, se definen con el sufijo f0 como 3f0. El sufijo e0 tambi√©n se puede usar para definir precisi√≥n doble (64 bit). El cero del sufijo en realidad tiene el objetivo de colocar el punto decimal, en notaci√≥n de ingenier√≠a, e.g., \\(0.003\\) se define como \\(3f-3\\) o \\(3e-3\\), dependiendo del tipo de dato que se necesite. Si se omite sufijo y se pone solo punto decimal entonces se interpretar√° como precision doble. Los tipos son Float32 y Float64.\nLos datos booleanos se indican mediante true y false para verdadero y falso, respectivamente.\nLos caracteres son s√≠mbolos para √≠ndicar cadenas, se suelen representar como enteros peque√±os en memoria. Se especifican con comillas simples 'a', 'z', '!' y soporta simbolos unicode 'ü§†'.\nLas cadenas de caracteres son la manera de representar textos como datos, se guardan en zonas contiguas de memoria. Se especifican con comillas dobles y tambi√©n soportan s√≠mbolos unicode, e.g., \"hola mundo\", \"pato es un üê∑\".\n\n\nJulia guarda los s√≠mbolos de manera especial y pueden ser utilizados para realizar identificaci√≥n de datos eficiente, sin embargo, no es buena idea saturar el sistema de manejo de s√≠mbolos por ejemplo para crear un vocabulario ya que no liberar√° la memoria despu√©s de definirlos ya que es un mec√°nismo dise√±ado para la representaci√≥n de los programas, pero lo suficientemente robusto y bien definido para usarse en el dise√±o e implementaci√≥n de programas de los usuarios.\nEn Julia existe la noci√≥n de s√≠mbolo, que es una cadena que adem√°s solo existe en una posici√≥n en memoria se usa el prefijo : para denotarlos.\n\nprintln(:hola === :hola)\nprintln(typeof(:hola))\nprintln(Symbol(\"hola mundo\"))\n\ntrue\nSymbol\nhola mundo\n\n\n\n\n\n1.2.6 Control de flujo\nEl control de flujo nos permite escoger que partes del c√≥digo se ejecutaran como consecuencia de la evaluaci√≥n de una expresi√≥n, esto incluye repeticiones.\nLas condicionales son el control de flujo m√°s simple.\n\na = 10\n1if a % 2 == 0\n2    \"par\"\nelse\n3    \"impar\"\nend\n\n\n1\n\nExpresi√≥n condicional.\n\n2\n\nExpresi√≥n a ejecutarse si (1) es verdadero.\n\n3\n\nExpresi√≥n a evaluarse si (1) es falso.\n\n\n\n\n\"par\"\n\n\nSe puede ignorar la clausula else dando solo la opci√≥n de evaluar (2) si (1) es verdadero. Finalmente, note que la condicional es una expresi√≥n y devuelve un valor.\n\na = 10\nif log10(a) == 1\n    \"es 10\"\nend\n\n\"es 10\"\n\n\nTambi√©n pueden concatenarse m√∫ltiples expresiones condicionales con elseif como se muestra a continuaci√≥n.\n\na = 9\nif a % 2 == 0\n    println(\"divisible entre 2\")\nelseif a % 3 == 0\n    println(\"divisible entre 3\")\nelse\n    println(\"no divisible entre 2 y 3\")\nend\n\ndivisible entre 3\n\n\nEs com√∫n utilizar la sintaxis en Julia (short circuit) para control de flujo:\n\na = 9\n\n1println(a % 2 == 0 && \"es divisible entre dos\")\n2println(a % 3 == 0 && \"es divisible entre tres\")\n\n\n1\n\nEl resultado de la condici√≥n es falso, por lo que no se ejecutar√° la siguiente expresi√≥n.\n\n2\n\nEl resultado es verdadero, por lo que se ejecutar√° la segunda expresi√≥n.\n\n\n\n\nfalse\nes divisible entre tres\n\n\nFnalmente, existe una condicional de tres vias expresion ? expr-verdadero : expr-falso\n\na = 9\n\nprintln(a % 2 == 0 ? \"es divisible entre dos\" : \"no es divisible entre dos\")\nprintln(a % 3 == 0 ? \"es divisible entre tres\" : \"no es divisible entre tres\")\n\nno es divisible entre dos\nes divisible entre tres\n\n\n\n1.2.6.1 Ciclos\nLos ciclos son expresiones de control de flujo que nos permiten iterar sobre una colecci√≥n o repetir un c√≥digo hasta que se cumpla alguna condici√≥n. En Julia existen dos expresiones de ciclos:\n\nfor x in colecci√≥n ...expresiones... end y\nwhile condici√≥n ...expresioens... end\n\nEn el caso de for, la idea es iterar sobre una colecci√≥n, esta colecci√≥n puede ser un rango, i.e., inicio:fin, inicio:paso:fin, o una colecci√≥n como las tuplas, los arreglos, o cualquiera que cumpla con la interfaz de colecci√≥n iterable del lenguaje.\n\nfor i in 1:5\n    println(\"1er ciclo: \", i =&gt; i^2)\nend\n\nfor i in [10, 20, 30, 40, 50]\n    println(\"2do ciclo: \", i =&gt; i/10)\nend\n\n1er ciclo: 1 =&gt; 1\n1er ciclo: 2 =&gt; 4\n1er ciclo: 3 =&gt; 9\n1er ciclo: 4 =&gt; 16\n1er ciclo: 5 =&gt; 25\n2do ciclo: 10 =&gt; 1.0\n2do ciclo: 20 =&gt; 2.0\n2do ciclo: 30 =&gt; 3.0\n2do ciclo: 40 =&gt; 4.0\n2do ciclo: 50 =&gt; 5.0\n\n\nAl igual que en otros lenguajes modernos, se define la variante completa o comprehensive for que se utiliza para transformar la colecci√≥n de entrada en otra colecci√≥n cuya sintaxis se ejemplifica a continuaci√≥n:\n\na = [i =&gt; i^2 for i in 1:5]\nprintln(a)\n\n[1 =&gt; 1, 2 =&gt; 4, 3 =&gt; 9, 4 =&gt; 16, 5 =&gt; 25]\n\n\nTambi√©n es posible definir un generador, esto es, un c√≥digo que puede generar los datos, pero que no los generar√° hasta que se les solicite.\n\na = (i =&gt; i^2 for i in 1:5)\nprintln(a)\nprintln(collect(a))\n\nBase.Generator{UnitRange{Int64}, var\"#3#4\"}(var\"#3#4\"(), 1:5)\n[1 =&gt; 1, 2 =&gt; 4, 3 =&gt; 9, 4 =&gt; 16, 5 =&gt; 25]\n\n\nOtra forma de hacer ciclos de intrucciones es repetir mientras se cumpla una condici√≥n:\n\ni = 0\nwhile i &lt; 5\n    i += 1\n    println(i)\nend\n\ni\n\n1\n2\n3\n4\n5\n\n\n5\n\n\n\n\n\n1.2.7 Tuplas y arreglos en Julia\nUna tupla es un conjunto ordenado de datos que no se puede modificar y que se desea esten contiguos en memoria, la sintaxis en memoria es como sigue:\n\n1a = (2, 3, 5, 7)\nb = (10, 20.0, 30f0)\nc = 100 =&gt; 200\n2println(typeof(a))\nprintln(typeof(b))\nprintln(typeof(c))\n3a[1], a[end], b[3], c.first, c.second\n\n\n1\n\nDefine las tuplas.\n\n2\n\nImprime los tipos de las tuplas.\n\n3\n\nMuestra como se accede a los elementos de las tuplas. Julia indexa comenzando desde 1, y el t√©rmino end tambi√©n se utiliza para indicar el √∫ltimo elemento en una colecci√≥n ordenada.\n\n\n\n\nNTuple{4, Int64}\nTuple{Int64, Float64, Float32}\nPair{Int64, Int64}\n\n\n(2, 7, 30.0f0, 100, 200)\n\n\nLa misma sintaxis puede generar diferentes tipos de tuplas. En el caso NTuple{4, Int4} nos indica que el tipo maneja cuatro elementos de enteros de 64 bits, los argumentos entre {} son parametros que especifican los tipos en cuesti√≥n. En el caso de Tuple se pueden tener diferentes tipos de elementos. La tupla Pair es especial ya que solo puede contener dos elementos y es b√°sicamente para embellecer o simplificar las expresiones; incluso se crea con la sintaxis key =&gt; value y sus elementos pueden accederse mediante dos campos nombrados.\nLos arreglos son datos del mismo tipo contiguos en memoria, a diferencia de las tuplas, los elementos se pueden modificar, incluso pueden crecer o reducirse. Esto puede implicar que se alojan en zonas de memoria diferente (las tuplas se colocan en el stack y los arreglos en el heap, ver la siguiente unidad para m√°s informaci√≥n). Desde un alto nivel, los arreglos en Julia suelen estar asociados con vectores, matrices y tensores, y un arsenal de funciones relacionadas se encuentran definidas en el paquete LinearAlgebra, lo cual esta m√°s all√° del alcance de este curso.\n\n1a = [2, 3, 5, 7]\nb = [10, 20.0, 30f0]\n2println(typeof(a))\nprintln(typeof(b))\n3a[1], a[end], b[3], b[2:3]\n\n\n1\n\nDefine los arreglos a y b.\n\n2\n\nMuestra los tipos de los arreglos, note como los tipos se promueven al tipo m√°s g√©nerico que contiene la definici√≥n de los datos.\n\n3\n\nEl acceso es muy similar a las tuplas para arreglos unidimensionales, note que es posible acceder rangos de elementos con la sintaxis ini:fin.\n\n\n\n\nVector{Int64}\nVector{Float64}\n\n\n(2, 7, 30.0, [20.0, 30.0])\n\n\n\na = [2 3;\n1     5 7]\n2display(a)\n3display(a[:, 1])\n4display(a[1, :])\n\n\n1\n\nDefinici√≥n de un arreglo bidimensional, note como se ignora la coma , en favor de la escritura por filas separadas por ;.\n\n2\n\nLa variable a es una matriz de 2x2.\n\n3\n\nEs posible acceder una columna completa usando el s√≠mbolo : para indicar todos los elementos.\n\n4\n\nDe igual forma, es posible acceder una fila completa.\n\n\n\n\n2√ó2 Matrix{Int64}:\n 2  3\n 5  7\n\n\n2-element Vector{Int64}:\n 2\n 5\n\n\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n1.2.8 Diccionarios y conjuntos en Julia\nUn diccionario es un arreglo asociativo, i.e., guarda pares llave-valor. Permite acceder de manera eficiciente al valor por medio de la llave, as√≠ como tambi√©n verificar si hay una entrada dentro del diccionario con una llave dada. La sintaxis es como sigue:\n\n1a = Dict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 3)\n2a[:b] = 20\nprintln(a)\n3a[:d] = 4\nprintln(a)\n4delete!(a, :a)\na\n\n\n1\n\nDefinici√≥n del diccionario a que mapea simbolos a enteros.\n\n2\n\nCambia el valor de :b por 20.\n\n3\n\nA√±ade :d =&gt; 4 al diccionario a.\n\n4\n\nBorra el par con llave :a.\n\n\n\n\nDict(:a =&gt; 1, :b =&gt; 20, :c =&gt; 3)\nDict(:a =&gt; 1, :b =&gt; 20, :d =&gt; 4, :c =&gt; 3)\n\n\nDict{Symbol, Int64} with 3 entries:\n  :b =&gt; 20\n  :d =&gt; 4\n  :c =&gt; 3\n\n\nEs posible utilizar diferentes tipos siempre y cuando el tipo en cuesti√≥n defina de manera correcta la funci√≥n hash sobre la llave y la verificaci√≥n de igualdad ==.\nUn conjunto se representa con el tipo Set, se implementa de manera muy similar al diccionario pero solo necesita el elemento (e.g., la llave). Como conjunto implementa las operaciones clasificaci√≥n de operaciones de conjuntos\n\n1a = Set([10, 20, 30, 40])\n2println(20 in a)\n3push!(a, 50)\nprintln(a)\n4delete!(a, 10)\nprintln(a)\n5println(intersect(a, [20, 35]))\n6union!(a, [100, 200])\nprintln(a)\n\n\n1\n\nDefinici√≥n del conjunto de n√∫meros enteros.\n\n2\n\nVerificaci√≥n de membresia al conjunto a.\n\n3\n\nA√±ade 50 al conjunto.\n\n4\n\nSe borra el elemento 10 del conjunto.\n\n5\n\nIntersecci√≥n de a con una colecci√≥n, no se modifica el conjunto a.\n\n6\n\nUni√≥n con otra colecci√≥n, se modifica a.\n\n\n\n\ntrue\nSet([50, 20, 10, 30, 40])\nSet([50, 20, 30, 40])\nSet([20])\nSet([50, 200, 20, 30, 40, 100])",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "01-intro.html#estructuras",
    "href": "01-intro.html#estructuras",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "1.5 Estructuras",
    "text": "1.5 Estructuras\n\nstruct Point\n  x::Float32\n  y::Float32\nend\n\nLa idea suele ser que todo se use de manera armoniosa\n\n\"\"\"\n  Calcula la norma de un vector representado\n  como un tupla\n\"\"\"\nfunction norm(u::Tuple)\n  s = 0f0\n\n  for i in eachindex(u)\n    s += u[i]^2\n  end\n\n  sqrt(s)\nend\n\n\"\"\"\n  Calcula la norma de un vector de 2 dimensiones\n  representado como una estructura\n\"\"\"\nfunction norm(u::Point)\n  sqrt(u.x^2 + u.y^2)\nend\n\n(norm((1, 1, 1, 1)), norm(Point(1, 1)))\n\n(2.0f0, 1.4142135f0)",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "01-intro.html#usando-modulos-y-paquetes",
    "href": "01-intro.html#usando-modulos-y-paquetes",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "1.7 Usando modulos y paquetes",
    "text": "1.7 Usando modulos y paquetes\n\n1.7.1 Instalaci√≥n",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "01-intro.html#arreglos",
    "href": "01-intro.html#arreglos",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "1.6 Arreglos",
    "text": "1.6 Arreglos\nUna matriz aleatoria de \\(4 \\times 6\\) se define como sigue\n\nA = rand(Float32, 4, 6)\n\n4√ó6 Matrix{Float32}:\n 0.700529  0.732714    0.0466642  0.146608  0.954517  0.186756\n 0.521717  0.766032    0.613469   0.650057  0.185905  0.953748\n 0.389262  0.405451    0.403303   0.634714  0.131284  0.0606382\n 0.594342  0.00968492  0.552823   0.938109  0.689677  0.88664\n\n\nUn vector aleatorio de 6 dimensiones ser√≠a como sigue:\n\nx = rand(Float32, 4)\n\n4-element Vector{Float32}:\n 0.10755324\n 0.6068469\n 0.45817447\n 0.60251594\n\n\nentonces podriamos multiplicar x con A como sigue:\n\ny = x' * A\n\n1√ó6 adjoint(::Vector{Float32}) with eltype Float32:\n 0.928397  0.735272  0.895168  1.26629  0.69117  1.16086\n\n\n\ny'\n\n6-element Vector{Float32}:\n 0.9283967\n 0.7352722\n 0.8951683\n 1.2662883\n 0.6911697\n 1.1608628\n\n\nTambi√©n existen otras formas para realizarla, aunque no suelen ser la mejor idea si se tienen alternativas can√≥nicas:\n\nusing LinearAlgebra\n\ndot.(Ref(x), eachcol(A))\n\nWARNING: using LinearAlgebra.norm in module Notebook conflicts with an existing identifier.\n\n\n6-element Vector{Float32}:\n 0.92839676\n 0.7352723\n 0.8951683\n 1.2662883\n 0.6911697\n 1.1608628\n\n\nEste ejemplo muestra la t√©cnica broadcasting que aplica una funci√≥n a una colecci√≥n; se indica a√±adiendo un punto al final del nombre de la funci√≥n. Adicionalmente, hay una serie de reglas que se deben seguir para el manejo de las colecciones. La funci√≥n eachcol crea un iterador sobre cada columna de la matriz A y Ref(x), nos permite que el broadcasting reconozca al vector x como un √∫nico elemento en lugar de una colecci√≥n de valores.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "01-intro.html#paquetes-y-m√≥dulos",
    "href": "01-intro.html#paquetes-y-m√≥dulos",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "1.7 Paquetes y m√≥dulos",
    "text": "1.7 Paquetes y m√≥dulos\nEl ecosistema de paquetes de Julia es una de sus mayores fortalezas, impulsado por usu gestor de paquetes Pkg, el cual viene integrado en el REPL y en la su instalaci√≥n m√≠nima; es muy robusto. Se encarga de la instalaci√≥n y actualizaci√≥n de librer√≠as, as√≠ como tambi√©n garantiza la reproducibilidad de los proyectos. Cada ambiente de trabajo en Julia utiliza archivos como Project.toml y Manifest.toml para registrar la paqueter√≠a usada, as√≠ como las versiones necesarias de todas las dependencias.\n\n1.7.1 Pkg en REPL\nPara entrar al modo Pkg desde cualquier sesi√≥n de Julia en el REPL se debe teclear _corchete cerrado ].\nEl prompt del REPL cambiar√°:\n\n\n\nModo\nPrompt\n\n\n\n\nNormal (Julia)\njulia&gt;\n\n\nModo Pkg\n(@v1.10) pkg&gt;\n\n\n\nAhora se puede ver qu√© paquetes est√°n instalados en tu entorno actual.\n\n\n\n\n\n\n\nComando\nAcci√≥n\n\n\n\n\nst o status\nMuestra la lista de todos los paquetes instalados y sus versiones espec√≠ficas.\n\n\n\nPara a√±adir una paquete a tu entorno, usa el comando add.\n\n\n\nComando\nAcci√≥n\n\n\n\n\nadd Paquete\nDescarga e instala el paquete.\n\n\n\nEn el caso de que un paquete ya no sea necesario, se puede desinstalar con el comando rm (de remove).\n\n\n\nComando\nAcci√≥n\n\n\n\n\nrm Paquete\nElimina el paquete del entorno actual.\n\n\n\nFinalmente, es posible actualizar paquetes de manera individual o colectiva usando el comando up.\n\n\n\n\n\n\n\nComando\nAcci√≥n\n\n\n\n\nup o update\nActualiza todos los paquetes instalados a su √∫ltima versi√≥n compatible.\n\n\nup Paquete o update Paquete\nActualiza Paquete a su √∫ltima versi√≥n compatible.\n\n\n\n\n1.7.1.1 Manejo de ambientes\nEl entorno o ambiente (environment) se puede especificar de manera global o por diretorio, y nos sirve para aislar las aplicaciones y no entrar en dificultades por versiones.\n\n\n\nComando\nAcci√≥n\n\n\n\n\nactivate dir\nActiva el directorio dir como ambiente.\n\n\n\nSupongamos que nos comparten un proyecto escrito en julia, lo primero que debemos hacer es activar e instanciar el ambiente; la instanciaci√≥n es como sigue\n\n\n\n\n\n\n\nComando\nAcci√≥n\n\n\n\n\ninstantiate\nSe instalan todos los paquetes indicados por el ambiente.\n\n\n\nMuchas veces tambi√©n cambiamos paquetes locales que requiren reactualizar el ambiente, eso se consigue con ] resolve que actualizar√° las nuevas dependencias que cambiaron.\n\n\n1.7.1.2 Saliendo del modo Pkg\nPara volver al modo de ejecuci√≥n de c√≥digo normal de Julia, se debe presionar backspace.\nEl prompt cambiar√° de nuevo a julia&gt; y podr√°s usar los paquetes que instalaste con el comando using.\nusing DataFrames, CSV\nesto traera el paquete al entorno en memoria haciendo accesibles sus m√©todos y estructuras p√∫blicas.\n\n\n\n1.7.2 Usando Pkg desde el modo normal de Julia (fuera del modo Pkg del REPL)\nExiste un paquete interno de las instalaciones de julia llamado Pkg que es el que maneja todo lo anterior, este puede ser utilizado como cualquier paquete. Basicamente tiene funciones similares a las del modo Pkg (con nombres completos).\nEjemplos:\njulia&gt; import Pkg\njulia&gt; Pkg.add(\"PlotlyLight\") \njulia&gt; Pkg.add([\"CSV\", \"DataFrames\"]) \njulia&gt; Pkg.rm(\"PlotlyLight\")\njulia&gt; Pkg.update()\njulia&gt; Pkg.status() \nAhora para el manejo de los ambientes:\njulia&gt; import Pkg\njulia&gt; Pkg.activate(\".\")\njulia&gt; Pkg.instantiate()\njulia&gt; Pkg.add(\"Statistics\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "01-intro.html#otras-estrategias-para-la-organizaci√≥n-de-c√≥digo",
    "href": "01-intro.html#otras-estrategias-para-la-organizaci√≥n-de-c√≥digo",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "1.8 Otras estrategias para la organizaci√≥n de c√≥digo",
    "text": "1.8 Otras estrategias para la organizaci√≥n de c√≥digo\nLa funci√≥n include(\"nombre_archivo.jl\") es el m√©todo m√°s simple en Julia para organizar c√≥digo en m√∫ltiples archivos. Su funci√≥n es equivalente a copiar y pegar el contenido del archivo especificado directamente en la l√≠nea donde se llama a include.\nSirve para estructurar grandes scripts en archivos m√°s peque√±os y manejables; el c√≥digo incluido se ejecuta en el mismo alcance (scope) donde se llam√≥ a include. Si llamas a include en el alcance global, las funciones y variables definidas en el archivo incluido se vuelven globales. Si lo llamas dentro de un m√≥dulo, se vuelven parte de ese m√≥dulo.\nEs simple, pero no proporciona aislamiento, y puede generar conflictos de nombres si no se usa de manera adecuada.\nPor otro lado, los m√≥dulos permmiten crear espacios de nombres (namespaces) aislados y bien definidos, utiles para organizar proyectos grandes y complejos.\n\n1.8.1 Aislamiento y alcance (Scoping)\nUn m√≥dulo act√∫a como una caja que encierra sus funciones y variables. Todo lo que se define dentro de un m√≥dulo es privado por defecto para evitar conflictos de nombres con c√≥digo externo.\nmodule MiCalculadora\n    # Esta funci√≥n es PRIVADA\n    function interna(x)\n        return x * 2\n    end\n\n    # Esta funci√≥n se hace P√öBLICA con 'export'\n    export sumar\n\n    function sumar(a, b)\n        return a + b\n    end\nend\nPara que las funciones, tipos o constantes dentro de un m√≥dulo sean accesibles desde afuera, deben ser expl√≠citamente exportadas utilizando la palabra clave export.\nLos modulos pueden anidarse.\nPara utilizar las funciones de un m√≥dulo en otro script o en el REPL, se usan dos comandos principales:\n\n\n\n\n\n\n\nComando\nAcci√≥n\n\n\n\n\nusing NombreModulo\nImporta solo los s√≠mbolos que han sido exportados por el m√≥dulo.\n\n\nimport NombreModulo\nImporta el m√≥dulo completo. Para usar sus funciones, debes prefijarlas (ej: NombreModulo.sumar(1, 2)).\n\n\n\nEn la pr√°ctica, un paquete o un proyecto grande de Julia casi siempre usa tanto include como m√≥dulos. De esta manera, include ayuda a la organizaci√≥n de archivos, mientras que el bloque module garantiza que todo el c√≥digo est√© contenido en un espacio de nombres √∫nico y limpio, evitando colisiones.\nEn particular, los paquetes pueden verse como la preparaci√≥n de un m√≥dulo para su distribuci√≥n, indicando los paquetes que usan (dependencias) y sus versiones especificas para los cuales fueron dise√±ados. Tambi√©n suelen incluir documentaci√≥n y pruebas unitarias.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "01-intro.html#recursos-para-aprender-m√°s-sobre-el-lenguaje",
    "href": "01-intro.html#recursos-para-aprender-m√°s-sobre-el-lenguaje",
    "title": "1¬† El lenguaje de programaci√≥n Julia",
    "section": "1.9 Recursos para aprender m√°s sobre el lenguaje",
    "text": "1.9 Recursos para aprender m√°s sobre el lenguaje\n\nInformaci√≥n sobre como instalar Julia y flujos de trabajo simples (e.g., REPL, editores, etc.) para trabajar con este lenguaje de programaci√≥n: Modern Julia Workflows https://modernjuliaworkflows.github.io/.\nLibro sobre julia Think Julia: How to Think Like a Computer Scientist https://benlauwens.github.io/ThinkJulia.jl/latest/book.html.\nCurso Introduction to computational thinking https://computationalthinking.mit.edu/Fall20/",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>El lenguaje de programaci√≥n Julia</span>"
    ]
  },
  {
    "objectID": "02-data-vis.html",
    "href": "02-data-vis.html",
    "title": "2¬† ‚Äî 2. Crear un archivo CSV de ejemplo ‚Äî",
    "section": "",
    "text": "using CSV\nusing DataFrames\nusing Dates\nusing PlotlyLight\n\n\nprintln(\"-&gt; Creando el archivo 'datos_ventas.csv'...\")\n\n# Simular datos para un DataFrame\ndata = DataFrame(\n    Producto = [\"Laptop\", \"Monitor\", \"Teclado\", \"Mouse\", \"Laptop\"],\n    Region = [\"Norte\", \"Sur\", \"Norte\", \"Centro\", \"Sur\"],\n    Ventas = [1500.50, 300.25, 50.00, 25.75, 1200.00],\n    Fecha = [Date(2023, 10, 1), Date(2023, 10, 5), Date(2023, 10, 10), Date(2023, 10, 15), Date(2023, 10, 20)]\n)\n\n# Escribir el DataFrame en un archivo CSV\nCSV.write(\"datos_ventas.csv\", data)\n\nprintln(\"Archivo CSV creado con √©xito.\")\nprintln(\"------------------------------------------\")\n\n# --- 3. Leer el archivo CSV en un DataFrame ---\nprintln(\"-&gt; Leyendo el archivo 'datos_ventas.csv' en un DataFrame...\")\n\n# Usamos CSV.File para leer los datos y luego lo convertimos a un DataFrame\ndf = CSV.read(\"datos_ventas.csv\", DataFrame)\n\nprintln(\"\\nDataFrame Le√≠do:\")\nprintln(df)\nprintln(\"------------------------------------------\")\n\n# --- 4. Manipulaci√≥n y An√°lisis B√°sico del DataFrame ---\n\nprintln(\"-&gt; An√°lisis B√°sico:\")\n\n# Mostrar el tipo de las columnas\nprintln(\"\\nTipos de Columnas:\")\nprintln(DataFrames.eltype.(eachcol(df)))\n\n# Filtrado de datos (solo ventas del Norte)\nprintln(\"\\nFiltrando: Solo ventas de la Regi√≥n Norte\")\ndf_norte = filter(:Region =&gt; r -&gt; r == \"Norte\", df)\nprintln(df_norte)\n\n# Agrupaci√≥n y Suma (ventas totales por Regi√≥n)\nprintln(\"\\nAgrupando: Ventas Totales por Regi√≥n\")\ndf_resumen = combine(groupby(df, :Region), :Ventas =&gt; sum =&gt; :Total_Ventas)\nprintln(df_resumen)\n\n-&gt; Creando el archivo 'datos_ventas.csv'...\nArchivo CSV creado con √©xito.\n------------------------------------------\n-&gt; Leyendo el archivo 'datos_ventas.csv' en un DataFrame...\n\nDataFrame Le√≠do:\n5√ó4 DataFrame\n Row ‚îÇ Producto  Region   Ventas   Fecha      \n     ‚îÇ String7   String7  Float64  Date       \n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n   1 ‚îÇ Laptop    Norte    1500.5   2023-10-01\n   2 ‚îÇ Monitor   Sur       300.25  2023-10-05\n   3 ‚îÇ Teclado   Norte      50.0   2023-10-10\n   4 ‚îÇ Mouse     Centro     25.75  2023-10-15\n   5 ‚îÇ Laptop    Sur      1200.0   2023-10-20\n------------------------------------------\n-&gt; An√°lisis B√°sico:\n\nTipos de Columnas:\nDataType[String7, String7, Float64, Date]\n\nFiltrando: Solo ventas de la Regi√≥n Norte\n2√ó4 DataFrame\n Row ‚îÇ Producto  Region   Ventas   Fecha      \n     ‚îÇ String7   String7  Float64  Date       \n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n   1 ‚îÇ Laptop    Norte     1500.5  2023-10-01\n   2 ‚îÇ Teclado   Norte       50.0  2023-10-10\n\nAgrupando: Ventas Totales por Regi√≥n\n3√ó2 DataFrame\n Row ‚îÇ Region   Total_Ventas \n     ‚îÇ String7  Float64      \n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n   1 ‚îÇ Norte         1550.5\n   2 ‚îÇ Sur           1500.25\n   3 ‚îÇ Centro          25.75\n\n\n\nusing PlotlyLight\n\nplot(x=1:100, y=cumsum(rand(100)))",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>--- 2. Crear un archivo CSV de ejemplo ---</span>"
    ]
  }
]